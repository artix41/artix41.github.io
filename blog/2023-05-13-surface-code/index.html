<!DOCTYPE html>
<html lang="en"><!--
 __  __                __                                     __
/\ \/\ \              /\ \             __                    /\ \
\ \ \_\ \   __  __    \_\ \      __   /\_\      __       ___ \ \ \/'\
 \ \  _  \ /\ \/\ \   /'_` \   /'__`\ \/\ \   /'__`\    /'___\\ \ , <
  \ \ \ \ \\ \ \_\ \ /\ \L\ \ /\  __/  \ \ \ /\ \L\.\_ /\ \__/ \ \ \\`\
   \ \_\ \_\\/`____ \\ \___,_\\ \____\ _\ \ \\ \__/.\_\\ \____\ \ \_\ \_\
    \/_/\/_/ `/___/> \\/__,_ / \/____//\ \_\ \\/__/\/_/ \/____/  \/_/\/_/
                /\___/                \ \____/
                \/__/                  \/___/

Powered by Hydejack v8.5.2 <https://hydejack.com/>
-->











<head>
  



<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">




  
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>An interactive introduction to the surface code | Arthur Pesah</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="An interactive introduction to the surface code" />
<meta name="author" content="Arthur Pesah" />
<meta property="og:locale" content="en" />
<meta name="description" content="Research blog" />
<meta property="og:description" content="Research blog" />
<link rel="canonical" href="https://arthurpesah.me/blog/2023-05-13-surface-code/" />
<meta property="og:url" content="https://arthurpesah.me/blog/2023-05-13-surface-code/" />
<meta property="og:site_name" content="Arthur Pesah" />
<meta property="og:image" content="https://arthurpesah.me/assets/img/blog/surface-code/thumbnail.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-05-13T00:00:00+02:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://arthurpesah.me/assets/img/blog/surface-code/thumbnail.png" />
<meta property="twitter:title" content="An interactive introduction to the surface code" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Arthur Pesah"},"dateModified":"2023-05-13T00:00:00+02:00","datePublished":"2023-05-13T00:00:00+02:00","description":"Research blog","headline":"An interactive introduction to the surface code","image":"https://arthurpesah.me/assets/img/blog/surface-code/thumbnail.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://arthurpesah.me/blog/2023-05-13-surface-code/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://arthurpesah.me/assets/icons/icon.png"},"name":"Arthur Pesah"},"url":"https://arthurpesah.me/blog/2023-05-13-surface-code/"}</script>
<!-- End Jekyll SEO tag -->


  

  
    <meta name="keywords" content="quantum computing,machine learning,research,papers,qml,quantum ML">
  


<meta name="mobile-web-app-capable" content="yes">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Arthur Pesah">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<meta name="application-name" content="Arthur Pesah">
<meta name="msapplication-config" content="/assets/ieconfig.xml">


<meta name="theme-color" content="rgb(25,55,71)">


<meta name="generator" content="Hydejack v8.5.2" />

<link type="application/atom+xml" rel="alternate" href="https://arthurpesah.me/feed.xml" title="Arthur Pesah" />



<link rel="alternate" href="https://arthurpesah.me/blog/2023-05-13-surface-code/" hreflang="en">

<link rel="shortcut icon" href="/assets/icons/favicon.ico">
<link rel="apple-touch-icon" href="/assets/icons/icon.png">

<link rel="manifest" href="/assets/manifest.json">


  <link rel="dns-prefetch" href="https://fonts.googleapis.com">
  <link rel="dns-prefetch" href="https://fonts.gstatic.com">


  <link rel="dns-prefetch" href="https://www.google-analytics.com">



<link rel="dns-prefetch" href="/" id="_baseURL">
<link rel="dns-prefetch" href="/sw.js" id="_hrefSW">
<link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.js" id="_hrefKatexJS">
<link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.css" id="_hrefKatexCSS">
<link rel="dns-prefetch" href="/assets/bower_components/katex/dist/contrib/copy-tex.min.js" id="_hrefKatexCopyJS">
<link rel="dns-prefetch" href="/assets/bower_components/katex/dist/contrib/copy-tex.min.css" id="_hrefKatexCopyCSS">
<link rel="dns-prefetch" href="/assets/img/swipe.svg" id="_hrefSwipeSVG">



<link rel="dns-prefetch" href="https://arthurpesah.disqus.com" id="_hrefDisqus">


<script>
!function(e,t){"use strict";function n(e,t,n,r){e.addEventListener?e.addEventListener(t,n,r):e.attachEvent?e.attachEvent("on"+t,n):e["on"+t]=n}e.loadJS=function(e,r){var o=t.createElement("script");o.src=e,r&&n(o,"load",r,{once:!0});var a=t.scripts[0];return a.parentNode.insertBefore(o,a),o},e._loaded=!1,e.loadJSDeferred=function(r,o){function a(){e._loaded=!0,o&&n(c,"load",o,{once:!0});var r=t.scripts[0];r.parentNode.insertBefore(c,r)}var c=t.createElement("script");return c.src=r,e._loaded?a():n(e,"load",a,{once:!0}),c},e.setRel=e.setRelStylesheet=function(e){function r(){this.rel="stylesheet"}var o=t.getElementById(e);n(o,"load",r,{once:!0})}}(window,document);
;
!function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this);
;
!function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this);
;
!function(w, d) {
  w._noPushState = false;
  w._noDrawer = false;
}(window, document);
</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3K1GWGLHP0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-3K1GWGLHP0');
</script>

<!--[if gt IE 8]><!---->











  <link rel="stylesheet" href="/assets/css/hydejack-8.5.2.css">
  <link rel="stylesheet" href="/assets/icomoon/style.css">
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:400|Noto+Sans:400,400i,700,700i&display=swap">
  


  <style id="_pageStyle">

.content a:not(.btn){color:#4fb1ba;border-color:rgba(79,177,186,0.2)}.content a:not(.btn):hover{border-color:#4fb1ba}:focus{outline-color:#4fb1ba !important}.btn-primary{color:#fff;background-color:#4fb1ba;border-color:#4fb1ba}.btn-primary:focus,.btn-primary.focus,.form-control:focus,.form-control.focus{box-shadow:0 0 0 3px rgba(79,177,186,0.5)}.btn-primary:hover,.btn-primary.hover{color:#fff;background-color:#409ba3;border-color:#409ba3}.btn-primary:disabled,.btn-primary.disabled{color:#fff;background-color:#4fb1ba;border-color:#4fb1ba}.btn-primary:active,.btn-primary.active{color:#fff;background-color:#409ba3;border-color:#409ba3}::selection{color:#fff;background:#4fb1ba}::-moz-selection{color:#fff;background:#4fb1ba}

</style>


<!--<![endif]-->




</head>

<body class="no-color-transition">
  <div id="_navbar" class="navbar fixed-top">
  <div class="content">
    <div class="nav-btn-bar">
      <span class="sr-only">Jump to:</span>
      <a id="_menu" class="nav-btn no-hover fl" href="#_navigation">
        <span class="sr-only">Navigation</span>
        <span class="icon-menu"></span>
      </a>
      <!-- <a id="_search" class="nav-btn no-hover fl" href="#_search">
        <span class="sr-only">Search</span>
        <span class="icon-search"></span>
      </a>
      <form action="https://duckduckgo.com/" method="GET">
        <div class="form-group fr">
          <label class="sr-only" for="_search">Search</label>
          <input id="_search" name="q" class="form-control" type="search" />
        </div>
        <input type="hidden" name="q" value="site:hydejack.com" />
        <input type="hidden" name="ia" value="web" />
      </form> -->
    </div>
  </div>
</div>
<hr class="sr-only" hidden />


<hy-push-state
  replace-ids="_main"
  link-selector="a[href]:not([href*='/assets/']):not(.external):not(.no-push-state)"
  duration="250"
  script-selector="script:not([type^='math/tex'])"
  prefetch
>
  
    <main
  id="_main"
  class="content fade-in layout-post"
  role="main"
  data-color="rgb(79,177,186)"
  data-theme-color="rgb(25,55,71)"
  
    data-image="/assets/img/sidebar-bg.jpg"
    data-overlay
  
  >
  




<article id="post-blog-surface-code" class="page post mb6" role="article">
  <header>
    <h1 class="post-title">
      
        An interactive introduction to the surface code
      
    </h1>

    <p class="post-date heading">
      
      <time datetime="2023-05-13T00:00:00+02:00">13 May 2023</time>
      
      
      
      
<!--      









in <a href="/blog/" class="flip-title">Blog</a>
-->
      









on <a href="/tag-quantum-computing/" class="flip-title">Quantum Computing</a>

    </p>

    
    
      <div class="img lead sixteen-nine">
        


  <test2></test2>
  <hy-img root-margin="511px" src="/assets/img/blog/surface-code/thumbnail.png"
    
    alt="An interactive introduction to the surface code"><img src="/assets/img/blog/surface-code/thumbnail.png"
    
    alt="An interactive introduction to the surface code"></hy-img>



      </div>
      
    

    



  


  </header>

  
    <script>
    // Repair modulo bug with negative numbers
    Number.prototype.mod = function (n) {
        "use strict";
        return ((this % n) + n) % n;
    };

    // Turn GUI into png
    function drawImage(gui, id, download) {
        gui.animate();

        let dataURL = gui.renderer.domElement.toDataURL();
        let img = new Image();
        img.src = dataURL;

        // Draw the Image object onto a new canvas

        requestAnimationFrame(function() {
            let newCanvas = document.createElement('canvas');
            let oldCanvas = document.getElementById(id).children[0];

            newCanvas.width = oldCanvas.offsetWidth;
            newCanvas.height = oldCanvas.offsetHeight;

            let ctx = newCanvas.getContext('2d');
            ctx.drawImage(img, 0, 0, newCanvas.width, newCanvas.height);

            oldCanvas.remove();

            let parent = document.getElementById(id);
            parent.appendChild(newCanvas);

            if (download) {
                let savedDataURL = newCanvas.toDataURL();
                let link = document.createElement('a');
                link.download = id + '.png';
                link.href = savedDataURL;
                document.body.appendChild(link);
                link.click();
            }
        });
    }

    const keycode = {
        'decode': -1, 'random': -1, 'remove': -1, 'opacity': -1,
        'x-logical': -1, 'z-logical': -1, 'x-error': 0, 'z-error': -1
    };
</script>

<p>Last July, the quantum team at Google released a <a href="https://arxiv.org/abs/2207.06431">milestone paper</a>, in which they show the first experimental demonstration of quantum error correction below threshold. What this means is that their experiment reached noise levels that are low enough such that by increasing the size of their code, they progressively reduced the number of errors in the encoded qubit. And how did they achieve such a milestone? You guessed it, by using the surface code to protect their qubits! The reasons they chose this code are plentiful: it can be layed down on a 2D lattice, it has a very high threshold compared to other codes, it doesn’t require too many qubits in its smallest instances, etc. And Google is far from the only company considering the surface code (or some of its variants) as part of their their fault-tolerant architecture!</p>

<p>Apart from its experimental relevance, the surface code is also one of the most beautiful ideas of quantum computing, and if you ask me, of all physics. Inspired by the condensed matter concepts of topological order and anyonic particle, it was discovered by Alexei Kitaev in 1997, in a <a href="https://arxiv.org/abs/quant-ph/9707021">paper</a> in which he also introduces the idea of topological quantum computing. And indeed, the surface code has deep connections to many areas of maths and physics. For instance, in condensed matter theory, the surface code (more often called <em>toric code</em> in this context<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>) is used as a prime example of topological phase of matter and is related to the more general family of spin liquids. While this post will be mainly concerned with the quantum error correction properties of the surface code, my friend Dominik Kufel wrote an excellent <a href="https://dom-kufel.github.io/blog/2023-05-13-toric_code-intro/">complementary post</a> which describes the condensed matter perspective.</p>

<p>Finally, the surface code is the simplest example to illustrate the more general concept of topological quantum error-correction. While we will only consider surface codes defined on a 2D square lattice here, they can actually be generalized to the cellulation of any manifold in any dimension (including hyperbolic!). Concepts from algebraic topology (such as homology and cohomology groups, chain complexes, etc.) can then be used to understand and analyze those codes. While we will take a brief glance at topology here, I am planning to write a separate blog post fully dedicated to the maths behind topological quantum error-correction. The goal of this post is to gain a first intuitive understanding of the surface code.</p>

<p>You got it, I love the surface code, and I’m super excited to talk about it in this post!
To do this code the honor it deserves, I’ve decided to make use of the <a href="https://gui.quantumcodes.io">interactive code visualizer</a> I have been developing for some time with my collaborator Eric Huang. I’ve embedded it in this post<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>, and you will therefore be able to play with some of the lattices presented here (e.g. by inserting errors and stabilizers, visualizing decoding, etc.). I hope you’ll enjoy!</p>

<p>So here is the plan for today’s post. We will first look at the definition of the surface code on a torus by laying out its stabilizers, see how to detect errors, and delve into topology in order to understand the logical operators of the code. We will then study the decoding problem and see how it can be simplified to a matching problem on a graph. Next, we will introduce the planar code and the rotated code, variants of the surface code with more practical boundary conditions and a lower overhead. Finally, we will define the notion of error correction threshold and give its different values for the surface code.</p>

<p>This post assumes familiarity with the stabilizer formalism, so don’t hesitate to read <a href="/blog/2023-01-31-stabilizer-formalism-1/">my blog post series</a> on the topic if you need a reminder.</p>

<h2 id="definition-of-the-surface-code">Definition of the surface code</h2>

<p>The surface code can be defined on a square grid of size <code class="MathJax_Preview">L \times L</code><script type="math/tex">L \times L</script>, where qubits sit on the edges, as shown here for <code class="MathJax_Preview">L=4</code><script type="math/tex">L=4</script>:</p>

<!-- <div id="surface-code-lattice" style="margin: auto; display: block; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-lattice';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init();

    drawImage(gui, id, true);
</script> -->

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-lattice.png"><img src="/assets/img/blog/surface-code/surface-code-lattice.png"></hy-img>

</p>

<p>The code is easier to analyze at first when considering periodic boundary conditions. Therefore, in the picture above, we identify the left-most and right-most qubits, as well as the top-most and bottom-most qubits. The grid is therefore equivalent to a pac-man grid, or in topological terms, a <strong>torus</strong>. A torus as you might imagine it can be obtained from the grid by wrapping it around top to bottom (gluing the top and bottom edges together), making a cylinder, then left to right (gluing the left and right edges together) to finish the torus:</p>

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/torus-grid.png" height="200"><img src="/assets/img/blog/surface-code/torus-grid.png" height="200"></hy-img>

</p>

<p>The next step is then to describe the <strong>stabilizers</strong> of the code. The surface code is indeed an example of stabilizer codes and can therefore be completely specified by its stabilizer group. In our case, we have two types of stabilizer generators: the <strong>vertex stabilizers</strong>, defined on every vertex of the lattice as a cross of four <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> operators, and the <strong>plaquette stabilizers</strong>, defined on every face as a square of four <code class="MathJax_Preview">X</code><script type="math/tex">X</script> operators. Examples of vertex and plaquette stabilizers are shown below, where <em>red</em> means <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <em>blue</em> mean <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script>.</p>

<!-- <div id="surface-code-stabilizers" style="margin: auto; display: block; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-stabilizers';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([1, 4], 'X');
    gui.code.insertError([0, 5], 'X');
    gui.code.insertError([1, 6], 'X');
    gui.code.insertError([2, 5], 'X');

    gui.code.insertError([3, 2], 'Z');
    gui.code.insertError([4, 3], 'Z');
    gui.code.insertError([4, 1], 'Z');
    gui.code.insertError([5, 2], 'Z');

    drawImage(gui, id, true);
</script> -->

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-stabilizers.png"><img src="/assets/img/blog/surface-code/surface-code-stabilizers.png"></hy-img>

</p>

<p>To define a valid code, <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> stabilizers must commute. Since they are Pauli operators, it means that they must always intersect on an even number of qubits. You can check that this is the case here: vertex and plaquette operators always intersect on either zero or two qubits.</p>

<p>Since the stabilizer group is a group, it means that the product of stabilizers is also a stabilizer. Therefore, any product of plaquettes is also a stabilizer. Here is an example of product of three plaquettes:</p>

<!-- <div id="surface-code-x-loops" style="margin: auto; display: block; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-x-loops'

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([0, 3], 'X');
    gui.code.insertError([0, 5], 'X');
    gui.code.insertError([1, 6], 'X');
    gui.code.insertError([2, 5], 'X');
    gui.code.insertError([3, 4], 'X');
    gui.code.insertError([4, 3], 'X');
    gui.code.insertError([3, 2], 'X');
    gui.code.insertError([1, 2], 'X');

    drawImage(gui, id, true);
</script> -->

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-x-loops.png"><img src="/assets/img/blog/surface-code/surface-code-x-loops.png"></hy-img>

</p>

<p>You can notice that this forms a loop! The reason is that when multiplying the plaquette operators, there are always two <code class="MathJax_Preview">X</code><script type="math/tex">X</script> operators applied on each qubit of the bulk, which cancel each other. This observation is true in general: all the <code class="MathJax_Preview">X</code><script type="math/tex">X</script> stabilizers are loops in the lattice! To convince yourself of that fact, try inserting plaquette stabilizers in the following panel:</p>

<div style="text-align: center; margin-bottom: 10px; color: gray; font-size: 15px">
    Click on faces to add plaquette stabilizers
</div>

<div id="surface-code-insert-plaquettes" style="margin: auto; display: block; max-width: 350px; height: 350px">
</div>

<div style="text-align: center; margin-bottom: 20px; font-size: 15px">
    <button id="button-surface-code-plaquette-reset">Remove all plaquettes</button>
</div>

<script type="module">
    import { Interface } from 'https://gui.quantumcodes.io/js/gui.js'

    let id = 'surface-code-insert-plaquettes'

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'https://gui.quantumcodes.io', id);

    let button = document.getElementById('button-surface-code-plaquette-reset');
    button.onclick = () => gui.removeAllErrors();

    gui.onDocumentMouseDown = function(event) {
        let canvasBound = gui.renderer.getContext().canvas.getBoundingClientRect();

        gui.mouse.x = ( (event.clientX  - canvasBound.left) / gui.width ) * 2 - 1;
        gui.mouse.y = - ( (event.clientY - canvasBound.top) / gui.height ) * 2 + 1;

        gui.raycaster.setFromCamera(gui.mouse, gui.camera);

        gui.intersects = gui.raycaster.intersectObjects(gui.code.stabilizers);
        if (this.intersects.length == 0) return;

        let selectedStabilizer = this.intersects[0].object;

        if (selectedStabilizer.type == 'face' && event.button == 0) {
            let x = selectedStabilizer.location[0];
            let y = selectedStabilizer.location[1];
            let z = selectedStabilizer.location[2];

            gui.code.insertError([(x+1).mod(8), y], 'X');
            gui.code.insertError([(x-1).mod(8), y], 'X');
            gui.code.insertError([x, (y+1).mod(8)], 'X');
            gui.code.insertError([x, (y-1).mod(8)], 'X');
        }
    }

    await gui.init()
</script>

<p>What about <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> stabilizers? They also form loops… if we look at them the right way! Try to understand why by inserting vertex stabilizers in the following panel:</p>

<div style="text-align: center; margin-bottom: 10px; color: gray; font-size: 15px">
    Click on vertices to add vertex stabilizers
</div>

<div id="surface-code-insert-vertex" style="margin: auto; display: block; max-width: 350px; height: 350px">
</div>

<div style="text-align: center; margin-bottom: 20px; font-size: 15px">
    <button id="button-surface-code-vertex-reset">Remove all vertex stabilizers</button>
</div>

<script type="module">
    import { Interface } from 'https://gui.quantumcodes.io/js/gui.js'

    let id = 'surface-code-insert-vertex'

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'https://gui.quantumcodes.io', id);

    let button = document.getElementById('button-surface-code-vertex-reset');
    button.onclick = () => gui.removeAllErrors();

    gui.onDocumentMouseDown = function(event) {
        let canvasBound = gui.renderer.getContext().canvas.getBoundingClientRect();

        gui.mouse.x = ( (event.clientX  - canvasBound.left) / gui.width ) * 2 - 1;
        gui.mouse.y = - ( (event.clientY - canvasBound.top) / gui.height ) * 2 + 1;

        gui.raycaster.setFromCamera(gui.mouse, gui.camera);

        gui.intersects = gui.raycaster.intersectObjects(gui.code.stabilizers);
        if (this.intersects.length == 0) return;

        let selectedStabilizer = this.intersects[0].object;

        if (selectedStabilizer.type == 'vertex' && event.button == 0) {
            let x = selectedStabilizer.location[0];
            let y = selectedStabilizer.location[1];
            let z = selectedStabilizer.location[2];

            gui.code.insertError([(x+1).mod(8), y], 'Z');
            gui.code.insertError([(x-1).mod(8), y], 'Z');
            gui.code.insertError([x, (y+1).mod(8)], 'Z');
            gui.code.insertError([x, (y-1).mod(8)], 'Z');
        }
    }

    await gui.init()
</script>

<p>For instance, here is the product of three vertex operators:</p>

<!-- <div id="surface-code-z-loops" style="margin: auto; display: block; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-z-loops'

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([4, 5], 'Z');
    gui.code.insertError([5, 4], 'Z');
    gui.code.insertError([5, 2], 'Z');
    gui.code.insertError([4, 1], 'Z');
    gui.code.insertError([2, 1], 'Z');
    gui.code.insertError([1, 2], 'Z');
    gui.code.insertError([2, 3], 'Z');
    gui.code.insertError([3, 4], 'Z');

    drawImage(gui, id, true);
</script> -->

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-z-loops.png"><img src="/assets/img/blog/surface-code/surface-code-z-loops.png"></hy-img>

</p>

<p>Can you see the loop? If no, this picture should make it clearer:</p>

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-z-loops-dual.png" height="320"><img src="/assets/img/blog/surface-code/surface-code-z-loops-dual.png" height="320"></hy-img>

</p>

<p>The trick was to draw an edge orthogonal to every blue edge (dashed purple lines on the figure). Formally, this corresponds to representing the operator in the so-called <strong>dual lattice</strong>, a lattice formed by rotating each edge by 90° (dashed grey lattice in the figure). In this lattice, vertex stabilizers have a square-like shape, similar to the plaquette stabilizers of the primal lattice. Therefore, all the properties we can derive for <code class="MathJax_Preview">X</code><script type="math/tex">X</script> stabilizers, errors and logicals can be directly translated to <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> operators by simply considering the dual lattice, where <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> operators behave exactly like <code class="MathJax_Preview">X</code><script type="math/tex">X</script> operators.</p>

<p>So we’ve seen that all the <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> stabilizers are loops in the lattice. But is the converse true, that is, do all the loops define stabilizers? Try to think about this question, we will come back to it later.</p>

<h2 id="detecting-errors">Detecting errors</h2>

<p>So what happens when errors start occurring on our code? Use the panel below to insert <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors in the code:</p>

<div style="text-align: center; margin-bottom: 10px; color: gray; font-size: 15px">
    Click on edges to add
    <select id="select-surface-code-error-type">
        <option value="x">X errors</option>
        <option value="z">Z errors</option>
    </select>
</div>

<div id="surface-code-insert-errors" style="margin: auto; display: block; max-width: 350px; height: 350px">
</div>

<div style="text-align: center; margin-bottom: 20px; font-size: 15px">
    <button id="button-surface-code-random">Insert random errors</button>
    <button id="button-surface-code-reset">Remove all errors</button>
</div>

<script type="module">
    import { Interface } from 'https://gui.quantumcodes.io/js/gui.js'

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        errorModel: 'Pure X',
        rotated: false
    };

    let gui = new Interface(params, {}, keycode, 'https://gui.quantumcodes.io', 'surface-code-insert-errors');

    await gui.init()
    gui.addRandomErrors();

    let button1 = document.getElementById('button-surface-code-random');
    button1.onclick = () => gui.addRandomErrors();

    let button2 = document.getElementById('button-surface-code-reset');
    button2.onclick = () => gui.removeAllErrors();

    let selectErrorType = document.getElementById('select-surface-code-error-type');
    selectErrorType.onchange = function() {
        if (selectErrorType.value == 'x') {
            gui.keycode['x-error'] = 0;
            gui.keycode['z-error'] = -1;
            gui.params.errorModel = 'Pure X';
        }
        else {
            gui.keycode['x-error'] = -1;
            gui.keycode['z-error'] = 0;
            gui.params.errorModel = 'Pure Z';
        }
    }
</script>

<p>Vertices lighted up in yellow are the ones which anticommute with the error and are equal to <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script>. They are part of the <strong>syndrome</strong> (set of measured stabilizer values) and are often called <strong>excitations</strong> or <strong>defects</strong>. Can you spot a pattern in the way excitations relates to errors? Let me help you. Start by removing all the errors. Then, draw a path of errors. Can you see what happens?</p>

<p>Excitations only appear at the boundary of error paths! Here is an example of pattern that should make that clear:</p>

<!-- <div id="surface-code-z-paths" style="margin: auto; display: block; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-z-paths';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([2, 3], 'Z');
    gui.code.insertError([4, 3], 'Z');
    gui.code.insertError([5, 4], 'Z');

    drawImage(gui, id, true);
</script> -->

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-x-paths.png"><img src="/assets/img/blog/surface-code/surface-code-x-paths.png"></hy-img>

</p>

<p>We can see that excitations are always created in pairs, and move through the lattice when increasing the size of the error string. What about <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors? The same phenomenon occurs if errors paths are created by adding errors on parallel edges:</p>

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-z-paths.png"><img src="/assets/img/blog/surface-code/surface-code-z-paths.png"></hy-img>

</p>

<p>As expected, when seen in the dual lattice (i.e. when rotating each edge by 90°), those <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> paths correspond to regular strings of errors.</p>

<p>The fact that excitations live at the boundary of error paths also means that when a path forms a loop, the excitations disappear. In other words, loops always commute with all the stabilizers. And what is an operator that commutes with all the stabilizers? A <a href="/blog/2023-03-16-stabilizer-formalism-2/">logical operator</a>!</p>

<h2 id="logical-operators-loops-and-topology">Logical operators, loops and topology</h2>

<p>A logical operator can either be trivial, in which case it is a stabilizer, or non-trivial, in which case it performs an <code class="MathJax_Preview">X</code><script type="math/tex">X</script>, <code class="MathJax_Preview">Y</code><script type="math/tex">Y</script> or <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> logical operation on any of the <code class="MathJax_Preview">k</code><script type="math/tex">k</script> qubits encoded in the code. For the surface code, the distinction between all those different operators depends on the types of loop they form. And this where the connection with topology really begins. Let’s first study the structure of loops on a general smooth manifold, before applying it to the surface code.</p>

<h3 id="loops-on-a-smooth-manifold">Loops on a smooth manifold</h3>

<p>Let’s consider a smooth manifold <code class="MathJax_Preview">\mathcal{M}</code><script type="math/tex">\mathcal{M}</script> (e.g. a torus). We say that two loops on <code class="MathJax_Preview">\mathcal{M}</code><script type="math/tex">\mathcal{M}</script> are <strong>equivalent</strong> if there exists a smooth deformation of one loop to the other, meaning that we can smoothly move the first loop to the other loop without cutting it<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>. For instance, the following four loops (green) on the torus are equivalent:</p>

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/torus-trivial-loops.png" height="200"><img src="/assets/img/blog/surface-code/torus-trivial-loops.png" height="200"></hy-img>

</p>

<p>Moreover, we say that a loop is <strong>contractible</strong>, or <strong>trivial</strong>, if it is equivalent to a point, that is, we can smoothly reduce it until it becomes a single point. All the loops in the figure above are examples of contractible loops on the torus. So what do non-contractible loops look like? Here are examples of non-contractible loops:</p>

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/torus-non-trivial-loops.png" height="200"><img src="/assets/img/blog/surface-code/torus-non-trivial-loops.png" height="200"></hy-img>

</p>

<p>One loop (blue) goes around the middle hole, while two loops (red) goes around the hole formed by the inside of the donut. Note that those types of loop (red and blue) are not equivalent to each other, and cannot be deformed to obtain any of the green loops of the first figure neither.</p>

<p>As always when we define a notion of equivalence, it can be interesting to look at all the different equivalence classes that they lead to. As a reminder, an <strong>equivalence class</strong>, or <strong>coset</strong>, is a set containing all the objects equivalent to a reference object. So let’s enumerate all the equivalence classes of loops on the torus. First, we have the contractible loops. They are all equivalent, since each of them can be reduced to a point, and two points can always be smoothly moved to each other. So that’s our first equivalent class, that we can call the <strong>trivial class</strong>. Then, we have the red and blue loops of the figure above: one that goes around the middle hole and the other that goes around the hole formed by the inside of the donut. That’s two other equivalent classes. Note that a pair of loops is also technically a loop itself, so taking the red and blue loops together forms its own loop, which is not equivalent to either one of them separately. This “double loop” can also be understood as (and is equivalent to) a single loop that goes around both holes, like the orange line in the picture below:</p>

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/torus-double-cycle.png" height="200"><img src="/assets/img/blog/surface-code/torus-double-cycle.png" height="200"></hy-img>

</p>

<p>So that’s a fourth equivalence class. Do we have more?</p>

<p>Yes! Loops going around a hole twice are not equivalent to loops going around the hole once. Therefore, for each <code class="MathJax_Preview">k \in \mathbb{N}</code><script type="math/tex">k \in \mathbb{N}</script>, we have a new class of loops going around one of the holes <code class="MathJax_Preview">k</code><script type="math/tex">k</script> times. Since in general loops are given a direction, we can also consider loops going around each hole in the opposite direction and take <code class="MathJax_Preview">k \in \mathbb{Z}</code><script type="math/tex">k \in \mathbb{Z}</script>. Overall, there are infinitely-many equivalence classes which can be labeled by two integers <code class="MathJax_Preview">(k_1,k_2) \in \mathbb{Z}^2</code><script type="math/tex">(k_1,k_2) \in \mathbb{Z}^2</script>, where each integer indicates how many times the loops go around the corresponding hole. In this notation, the trivial class corresponds to <code class="MathJax_Preview">(0,0)</code><script type="math/tex">(0,0)</script>, the blue and red non-trivial loops correspond to <code class="MathJax_Preview">(0,1)</code><script type="math/tex">(0,1)</script> and <code class="MathJax_Preview">(1,0)</code><script type="math/tex">(1,0)</script>, and the orange loop corresponds to <code class="MathJax_Preview">(1,1)</code><script type="math/tex">(1,1)</script>.</p>

<p class="message"><strong>Exercise 1</strong>: What is the equivalence class of the following (purple) loop? <a href="#solution-of-the-exercise">(solution)</a></p>
<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/torus-exercise.png" height="200"><img src="/assets/img/blog/surface-code/torus-exercise.png" height="200"></hy-img>

</p>

<h3 id="loops-on-the-surface-code">Loops on the surface code</h3>

<p>How can we apply what we have learned to the surface code? Compared to general smooth manifolds, the surface code has a more discrete structure, and the notion of <em>smoothly deforming a loop</em> does not directly apply here. We need a slightly different notion of equivalence<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>. We say that two loops <code class="MathJax_Preview">\ell_1,\ell_2</code><script type="math/tex">\ell_1,\ell_2</script> on the surface code are equivalent if there exists a stabilizer <code class="MathJax_Preview">S \in \mathcal{S}</code><script type="math/tex">S \in \mathcal{S}</script> such that <code class="MathJax_Preview">\ell_1 = S \ell_2</code><script type="math/tex">\ell_1 = S \ell_2</script>. For instance, if we consider <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors and <code class="MathJax_Preview">X</code><script type="math/tex">X</script> stabilizers, two loops of errors are equivalent if we can apply a series of plaquettes to go from one to the other. As an exercise, show that the following two loops are equivalent, by finding some plaquettes that move one loop to the other:</p>

<!-- <div id="surface-code-equivalent-loops-1" style="display: block;float: left; width: 350px; height: 350px">
</div>
<div id="surface-code-equivalent-loops-2" style="display: block;float: right; width: 350px; height: 350px">
</div>

<div style="clear: both"></div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-equivalent-loops-1';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([2, 7], 'X');
    gui.code.insertError([2, 1], 'X');
    gui.code.insertError([3, 2], 'X');
    gui.code.insertError([4, 1], 'X');
    gui.code.insertError([4, 7], 'X');
    gui.code.insertError([3, 6], 'X');

    drawImage(gui, id, true);
</script>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-equivalent-loops-2'

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([1, 4], 'X');
    gui.code.insertError([0, 3], 'X');
    gui.code.insertError([0, 1], 'X');
    gui.code.insertError([1, 0], 'X');
    gui.code.insertError([3, 0], 'X');
    gui.code.insertError([4, 1], 'X');
    gui.code.insertError([3, 2], 'X');
    gui.code.insertError([2, 3], 'X');

    drawImage(gui, id, true);
</script> -->

<p><hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-equivalent-loops-1.png" style="display: block; float: left;"><img src="/assets/img/blog/surface-code/surface-code-equivalent-loops-1.png" style="display: block; float: left;"></hy-img>

<hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-equivalent-loops-2.png" style="display: block; float: right;"><img src="/assets/img/blog/surface-code/surface-code-equivalent-loops-2.png" style="display: block; float: right;"></hy-img>
</p>

<div style="clear: both"></div>

<p>Note that this notion of equivalence is exactly the same as the notion of logical equivalence defined in <a href="/blog/2023-03-16-stabilizer-formalism-2/">Part II of the stabilizer formalism series</a>: applying a stabilizer to a logical gives another representation of the same logical. So operationally, two loops are equivalent if they correspond to the same logical operator. Therefore, by looking at all the equivalence classes of loops, we will be able to classify the different logical operators of the code.</p>

<p>Now, we say that a loop is <strong>contractible</strong>, or <strong>trivial</strong>, if it is equivalent to the empty loop (no error). In other words, a loop is trivial if it is a stabilizer. In the case of <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors, a trivial loop corresponds to the boundary of a set of faces (the plaquettes that form the stabilizer).</p>

<p>We are now ready to answer our main question. What are the non-trivial loops of the surface code, or in other words, the non-trivial logical operators? For <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors, they look like this:</p>

<!-- <div id="surface-code-x-logical-1" style="display: block; margin: auto; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-x-logical-1';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([2, 7], 'X');
    gui.code.insertError([2, 1], 'X');
    gui.code.insertError([2, 3], 'X');
    gui.code.insertError([2, 5], 'X');

    // drawImage(gui, id, true);
</script> -->

<!-- <div id="surface-code-x-logical-2" style="display: block; margin: auto; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-x-logical-2';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([7, 2], 'X');
    gui.code.insertError([1, 2], 'X');
    gui.code.insertError([5, 2], 'X');
    gui.code.insertError([3, 2], 'X');

    drawImage(gui, id, true);
</script> -->

<p><hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-x-logical-1.png" style="display: block; float: left"><img src="/assets/img/blog/surface-code/surface-code-x-logical-1.png" style="display: block; float: left"></hy-img>

<hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-x-logical-2.png" style="display: block; float: right"><img src="/assets/img/blog/surface-code/surface-code-x-logical-2.png" style="display: block; float: right"></hy-img>
</p>

<div style="clear: both"></div>

<p>And since applying plaquette stabilizers does not change the logical operator, the following strings give other valid representatives of the same logicals:</p>

<!-- <div id="surface-code-x-logical-1-other" style="display: block; margin: auto; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-x-logical-1-other';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([4, 7], 'X');
    gui.code.insertError([4, 5], 'X');
    gui.code.insertError([3, 4], 'X');
    gui.code.insertError([1, 4], 'X');
    gui.code.insertError([0, 3], 'X');
    gui.code.insertError([1, 2], 'X');
    gui.code.insertError([2, 1], 'X');
    gui.code.insertError([3, 0], 'X');

    // drawImage(gui, id, true);
</script>

<div id="surface-code-x-logical-2-other" style="display: block; margin: auto; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-x-logical-2-other';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([7, 2], 'X');
    gui.code.insertError([1, 2], 'X');
    gui.code.insertError([2, 3], 'X');
    gui.code.insertError([3, 4], 'X');
    gui.code.insertError([4, 3], 'X');
    gui.code.insertError([4, 1], 'X');
    gui.code.insertError([5, 0], 'X');
    gui.code.insertError([6, 1], 'X');

    drawImage(gui, id, true);
</script> -->

<p><hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-x-logical-1-other.png" style="display: block; float: left"><img src="/assets/img/blog/surface-code/surface-code-x-logical-1-other.png" style="display: block; float: left"></hy-img>

<hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-x-logical-2-other.png" style="display: block; float: right"><img src="/assets/img/blog/surface-code/surface-code-x-logical-2-other.png" style="display: block; float: right"></hy-img>
</p>

<div style="clear: both"></div>

<p>As in the smooth case, what matters is that the non-trivial loops go around the torus. Indeed, you will not be able to write those operators as products of plaquette stabilizers. Operationally, each of those two loops (the “horizontal” and the “vertical” ones) correspond to applying a logical <code class="MathJax_Preview">X</code><script type="math/tex">X</script> operator to the code, and since they are not equivalent, they are applying it to different logical qubits. Therefore, we have at least two logical qubits, one for the horizontal loop and one for the vertical loop. Do we have more?</p>

<p>This time, we only have four different cosets of loops. Indeed, contrary to the smooth case, looping around the lattice twice always gives a trivial loop. This can be seen in two ways. The first way consists in observing that a loop going around the lattice twice is always equivalent to two disjoint loops (this was also true in the smooth case).</p>

<p>The next step is then to show that such a two-loop pattern is always a stabilizer. For instance, try to find the plaquette stabilizers that give rise to the two loops on the right picture:</p>

<div style="float: left">
    <div style="text-align: center; margin-bottom: 10px; color: gray; font-size: 15px">
        Click on faces to add plaquette stabilizers
    </div>

    <div id="surface-code-insert-plaquettes-two-loops" style="margin: auto; display: block; max-width: 350px; height: 350px">
    </div>

    <div style="text-align: center; margin-bottom: 20px; font-size: 15px">
        <button id="button-surface-code-plaquette-two-loops-reset">Remove all plaquettes</button>
    </div>
</div>

<!-- Hidden text for positioning-->
<div style="float: right">
    <div style="text-align: center; margin-bottom: 10px; visibility: hidden; font-size: 15px">
        Click on faces to add plaquette stabilizers
    </div>
</div>
<p><hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-two-loops.png" style="float: right"><img src="/assets/img/blog/surface-code/surface-code-two-loops.png" style="float: right"></hy-img>
</p>

<div style="clear: both"></div>

<script type="module">
    import { Interface } from 'https://gui.quantumcodes.io/js/gui.js'

    let id = 'surface-code-insert-plaquettes-two-loops'

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, keycode, 'https://gui.quantumcodes.io', id);

    let button = document.getElementById('button-surface-code-plaquette-two-loops-reset');
    button.onclick = () => gui.removeAllErrors();

    gui.onDocumentMouseDown = function(event) {
        let canvasBound = gui.renderer.getContext().canvas.getBoundingClientRect();

        gui.mouse.x = ( (event.clientX  - canvasBound.left) / gui.width ) * 2 - 1;
        gui.mouse.y = - ( (event.clientY - canvasBound.top) / gui.height ) * 2 + 1;

        gui.raycaster.setFromCamera(gui.mouse, gui.camera);

        gui.intersects = gui.raycaster.intersectObjects(gui.code.stabilizers);
        if (this.intersects.length == 0) return;

        let selectedStabilizer = this.intersects[0].object;

        if (selectedStabilizer.type == 'face' && event.button == 0) {
            let x = selectedStabilizer.location[0];
            let y = selectedStabilizer.location[1];
            let z = selectedStabilizer.location[2];

            gui.code.insertError([(x+1).mod(8), y], 'X');
            gui.code.insertError([(x-1).mod(8), y], 'X');
            gui.code.insertError([x, (y+1).mod(8)], 'X');
            gui.code.insertError([x, (y-1).mod(8)], 'X');
        }
    }

    await gui.init()
</script>

<!-- <script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-two-loops';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([2, 7], 'X');
    gui.code.insertError([2, 1], 'X');
    gui.code.insertError([2, 3], 'X');
    gui.code.insertError([2, 5], 'X');
    gui.code.insertError([4, 7], 'X');
    gui.code.insertError([4, 1], 'X');
    gui.code.insertError([4, 3], 'X');
    gui.code.insertError([4, 5], 'X');

    drawImage(gui, id, true);
</script> -->

<!-- <div id="surface-code-two-loops-solution" style="display: block; margin: auto; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-two-loops-solution';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([2, 7], 'X');
    gui.code.insertError([2, 1], 'X');
    gui.code.insertError([2, 3], 'X');
    gui.code.insertError([2, 5], 'X');
    gui.code.insertError([4, 7], 'X');
    gui.code.insertError([4, 1], 'X');
    gui.code.insertError([4, 3], 'X');
    gui.code.insertError([4, 5], 'X');

    gui.code.stabilizerMap[[3, 1]].material.color.setHex('0xf9690e');
    gui.code.stabilizerMap[[3, 1]].material.opacity = 1;
    gui.code.stabilizerMap[[3, 1]].visible = true;

    gui.code.stabilizerMap[[3, 3]].material.color.setHex('0xf9690e');
    gui.code.stabilizerMap[[3, 3]].material.opacity = 1;
    gui.code.stabilizerMap[[3, 3]].visible = true;

    gui.code.stabilizerMap[[3, 5]].material.color.setHex('0xf9690e');
    gui.code.stabilizerMap[[3, 5]].material.opacity = 1;
    gui.code.stabilizerMap[[3, 5]].visible = true;

    gui.code.stabilizerMap[[3, 7]].material.color.setHex('0xf9690e');
    gui.code.stabilizerMap[[3, 7]].material.opacity = 1;
    gui.code.stabilizerMap[[3, 7]].visible = true;

    drawImage(gui, id, true);
</script> -->

<p>The second way to see this is to remember that a loop applies a logical operator <code class="MathJax_Preview">P</code><script type="math/tex">P</script>, and applying this logical operator twice gives <code class="MathJax_Preview">P^2=I</code><script type="math/tex">P^2=I</script>. It means that any double loop lives in the identity coset, and is therefore a stabilizer.</p>

<p>Thus, our equivalence classes for <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors can be labeled by two bits <code class="MathJax_Preview">(k_1,k_2) \in \mathbb{Z}_2 \times \mathbb{Z}_2</code><script type="math/tex">(k_1,k_2) \in \mathbb{Z}_2 \times \mathbb{Z}_2</script>. The corresponding logical operators are <code class="MathJax_Preview">I</code><script type="math/tex">I</script>, <code class="MathJax_Preview">X_1</code><script type="math/tex">X_1</script>, <code class="MathJax_Preview">X_2</code><script type="math/tex">X_2</script> and <code class="MathJax_Preview">X_1 X_2</code><script type="math/tex">X_1 X_2</script>. The fact that our sets are <code class="MathJax_Preview">\mathbb{Z}_2</code><script type="math/tex">\mathbb{Z}_2</script> instead of <code class="MathJax_Preview">\mathbb{Z}</code><script type="math/tex">\mathbb{Z}</script> can also be interpreted as a consequence of the fact that we have qubits. For qudits, the generalization of Pauli operators obey <code class="MathJax_Preview">P^d=I</code><script type="math/tex">P^d=I</script>, and <code class="MathJax_Preview">\mathbb{Z}_2</code><script type="math/tex">\mathbb{Z}_2</script> is replaced by <code class="MathJax_Preview">\mathbb{Z}_d</code><script type="math/tex">\mathbb{Z}_d</script>. For error-correcting codes on continuous-variable systems (roughly, qudits with <code class="MathJax_Preview">d=\infty</code><script type="math/tex">d=\infty</script>), we recover <code class="MathJax_Preview">\mathbb{Z}</code><script type="math/tex">\mathbb{Z}</script> as our space of equivalence classes<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>.</p>

<p>Let’s summarize what we have learned. Loops of the surface code define logical operators. There are four non-equivalent types of loops: the trivial ones (stabilizers), the horizontal ones (<code class="MathJax_Preview">X_1</code><script type="math/tex">X_1</script> operator), the vertical ones (<code class="MathJax_Preview">X_2</code><script type="math/tex">X_2</script> operator), and those two at the same time (<code class="MathJax_Preview">X_1 X_2</code><script type="math/tex">X_1 X_2</script> operator). Therefore, the surface code encodes <code class="MathJax_Preview">k=2</code><script type="math/tex">k=2</script> logical qubits.</p>

<p>Note that in general, the surface code can be defined on any smooth manifold <code class="MathJax_Preview">\mathcal{M}</code><script type="math/tex">\mathcal{M}</script> by discretizing it. The number of logical qubits of the code is then directly connected to the topological properties of the manifold, and in particular, to the number of holes, or in more technical terms, the <strong>first Betti number</strong> of the manifold. For instance, for the torus, the fact that <code class="MathJax_Preview">k=2</code><script type="math/tex">k=2</script> is a consequence of the presence of two holes.</p>

<p>So far, we have mainly discussed loops of <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors, but what about <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors? As expected, the <code class="MathJax_Preview">Z_1</code><script type="math/tex">Z_1</script> and <code class="MathJax_Preview">Z_2</code><script type="math/tex">Z_2</script> logicals correspond to loops going around the torus when considered in the dual lattice:</p>

<!-- <div id="surface-code-z-logical-1" style="margin: auto; display: block; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-z-logical-1';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([3, 0], 'Z');
    gui.code.insertError([3, 2], 'Z');
    gui.code.insertError([3, 4], 'Z');
    gui.code.insertError([3, 6], 'Z');

    // drawImage(gui, id, true);
</script>

<div id="surface-code-z-logical-2" style="margin: auto; display: block; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-z-logical-2';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()

    gui.code.insertError([0, 3], 'Z');
    gui.code.insertError([2, 3], 'Z');
    gui.code.insertError([4, 3], 'Z');
    gui.code.insertError([6, 3], 'Z');

    // drawImage(gui, id, true);
</script> -->

<p><hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-z-logical-1.png" style="display: block; float: left"><img src="/assets/img/blog/surface-code/surface-code-z-logical-1.png" style="display: block; float: left"></hy-img>

<hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-z-logical-2.png" style="display: block; float: right"><img src="/assets/img/blog/surface-code/surface-code-z-logical-2.png" style="display: block; float: right"></hy-img>
</p>

<div style="clear: both"></div>

<p>On the left is the <code class="MathJax_Preview">Z_1</code><script type="math/tex">Z_1</script> logical (which anticommute with <code class="MathJax_Preview">X_1</code><script type="math/tex">X_1</script>) and on the right is the <code class="MathJax_Preview">Z_2</code><script type="math/tex">Z_2</script> logical (which anticommute with <code class="MathJax_Preview">X_2</code><script type="math/tex">X_2</script>). Those anticommutation relation between <code class="MathJax_Preview">X_1</code><script type="math/tex">X_1</script> and <code class="MathJax_Preview">Z_1</code><script type="math/tex">Z_1</script> can be seen in this picture:</p>

<!-- <div id="surface-code-anticommutation" style="display: block; margin: auto; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-anticommutation';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([2, 7], 'X');
    gui.code.insertError([2, 1], 'X');
    gui.code.insertError([2, 3], 'X');
    gui.code.insertError([2, 5], 'X');

    gui.code.insertError([0, 3], 'Z');
    gui.code.insertError([2, 3], 'Z');
    gui.code.insertError([4, 3], 'Z');
    gui.code.insertError([6, 3], 'Z');

    // drawImage(gui, id, true);
</script> -->

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-anticommutation.png"><img src="/assets/img/blog/surface-code/surface-code-anticommutation.png"></hy-img>

</p>

<p>Indeed, we can see that the <code class="MathJax_Preview">X_1</code><script type="math/tex">X_1</script> and <code class="MathJax_Preview">Z_1</code><script type="math/tex">Z_1</script> logicals intersect on exactly one qubit (green), meaning that they anticommute. This property is independent on the specific logical representatives you choose: a “horizontal” <code class="MathJax_Preview">X</code><script type="math/tex">X</script> loop will always intersect with a “vertical” <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> loop on a single qubit.</p>

<p>You now have all you need to determine the parameters of the surface code!</p>

<p class="message"><strong>Exercise 2</strong>: What are the <code class="MathJax_Preview">[[n,k,d]]</code><script type="math/tex">[[n,k,d]]</script> parameters of a surface code with lattice size <code class="MathJax_Preview">L</code><script type="math/tex">L</script>? <a href="#solution-of-the-exercise">(solution)</a></p>

<h2 id="decoding-the-surface-code">Decoding the surface code</h2>

<p>Let’s imagine that you observe the following syndrome, and want to find a good correction operator.</p>

<!-- <div id="surface-code-syndrome" style="display: block; margin: auto; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-syndrome';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.toggleStabilizer(gui.code.stabilizerMap[[4, 4]], true);
    gui.code.toggleStabilizer(gui.code.stabilizerMap[[2, 2]], true);

    drawImage(gui, id, false);
</script> -->

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-syndrome.png"><img src="/assets/img/blog/surface-code/surface-code-syndrome.png"></hy-img>

</p>

<p>We know that excitations always appear in pairs, and correspond to the boundary of strings of errors.
So the error must be a string that links those two excitations. However, the number of strings that could have given this syndrome is very large! Here are three examples of errors leading to the syndrome shown above:</p>

<!-- <div id="surface-code-decoding-1" style="display: block; float: left; width: 250px; height: 250px">
</div>
<div id="surface-code-decoding-3" style="display: block; float: right; width: 250px; height: 250px">
</div>
<div id="surface-code-decoding-2" style="display: block; float: right; width: 250px; height: 250px">
</div>

<div style="clear: both"></div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js';

    let id = 'surface-code-decoding-1';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([3, 4], 'X');
    gui.code.insertError([2, 3], 'X');

    // drawImage(gui, id, true);
</script>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js';

    let id = 'surface-code-decoding-2';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([4, 3], 'X');
    gui.code.insertError([3, 2], 'X');

    drawImage(gui, id, true);
</script>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js';

    let id = 'surface-code-decoding-3';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([5, 4], 'X');
    gui.code.insertError([6, 3], 'X');
    gui.code.insertError([7, 2], 'X');
    gui.code.insertError([0, 1], 'X');
    gui.code.insertError([1, 0], 'X');
    gui.code.insertError([2, 1], 'X');

    // drawImage(gui, id, true);
</script> -->

<p><hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-decoding-1.png" style="display: block; float: left"><img src="/assets/img/blog/surface-code/surface-code-decoding-1.png" style="display: block; float: left"></hy-img>

<hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-decoding-3.png" style="display: block; float: right"><img src="/assets/img/blog/surface-code/surface-code-decoding-3.png" style="display: block; float: right"></hy-img>

<hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-decoding-2.png" style="display: block; float: right"><img src="/assets/img/blog/surface-code/surface-code-decoding-2.png" style="display: block; float: right"></hy-img>
</p>

<div style="clear: both"></div>

<p>Let’s suppose that the first pattern was our actual error, but we chose the middle pattern instead as our correction operator. This is what the final pattern, corresponding to the error (red) plus the correction operator (yellow), would look like:</p>

<!-- <div id="surface-code-correction-1" style="display: block; margin: auto; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-correction-1';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([3, 4], 'X');
    gui.code.insertError([2, 3], 'X');
    gui.code.insertError([4, 3], 'X');
    gui.code.insertError([3, 2], 'X');

    gui.code.qubitMap[[4, 3]].material.color.setHex('0xffdf00');
    gui.code.qubitMap[[3, 2]].material.color.setHex('0xffdf00');

    drawImage(gui, id, true);
</script> -->

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-correction-1.png"><img src="/assets/img/blog/surface-code/surface-code-correction-1.png"></hy-img>

</p>

<p>And as you can see, this is a stabilizer! So applying this correction operator puts us back in the original state and the correction is a success. On the other hand, here is what would happen if we had applied the last correction operator instead:</p>

<!-- <div id="surface-code-correction-2" style="display: block; margin: auto; width: 350px; height: 350px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-correction-2'

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([3, 4], 'X');
    gui.code.insertError([2, 3], 'X');

    gui.code.insertError([5, 4], 'X');
    gui.code.insertError([6, 3], 'X');
    gui.code.insertError([7, 2], 'X');
    gui.code.insertError([0, 1], 'X');
    gui.code.insertError([1, 0], 'X');
    gui.code.insertError([2, 1], 'X');

    gui.code.qubitMap[[5, 4]].material.color.setHex('0xffdf00');
    gui.code.qubitMap[[6, 3]].material.color.setHex('0xffdf00');
    gui.code.qubitMap[[7, 2]].material.color.setHex('0xffdf00');
    gui.code.qubitMap[[0, 1]].material.color.setHex('0xffdf00');
    gui.code.qubitMap[[1, 0]].material.color.setHex('0xffdf00');
    gui.code.qubitMap[[2, 1]].material.color.setHex('0xffdf00');

    drawImage(gui, id, false);
</script> -->

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-correction-2.png"><img src="/assets/img/blog/surface-code/surface-code-correction-2.png"></hy-img>

</p>

<p>As you can see, this is a logical operator! So this is an example of correction failure, where we have changed the logical state of our code when applying the correction.</p>

<p>What lessons can we draw from this example? The goal of the surface code decoding problem is to match the excitations such that the final operator is a stabilizer. Let’s try to formalize this a little bit. I described the general decoding problem for stabilizer codes in a <a href="/blog/2023-03-28-stabilizer-formalism-3/">previous post</a>, but a short reminder is probably warranted.</p>

<p>Similarly to how logical operators can be partitioned into cosets, we can also enumerate equivalent classes for errors fitting a given syndrome. For instance, the first and middle patterns in our example above are part of the same equivalent class, as they can be related by a plaquette stabilizer. On the other hand, the last string belongs to a different class. The goal of decoding is to find a correction operator that belongs to the same coset as the actual error. Indeed, the product <code class="MathJax_Preview">CE</code><script type="math/tex">CE</script> of the correction operator with the error is equal to a stabilizer if and only if there is a stabilizer <code class="MathJax_Preview">S</code><script type="math/tex">S</script> such that <code class="MathJax_Preview">C=ES</code><script type="math/tex">C=ES</script>, that is, if <code class="MathJax_Preview">C</code><script type="math/tex">C</script> and <code class="MathJax_Preview">E</code><script type="math/tex">E</script> belong to the same class. To solve this problem with the information we have, that is, only the syndrome and the error probabilities, the optimal decoding problem, also called <strong>maximum-likelihood decoding</strong>, can be formulated as finding the coset <code class="MathJax_Preview">\bm{\bar{C}}</code><script type="math/tex">\bm{\bar{C}}</script> with the highest probability:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
    \max_{\bm{\bar{C}}} P(\bm{\bar{C}})
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
    \max_{\bm{\bar{C}}} P(\bm{\bar{C}})
\end{aligned}</script>

<p>where <code class="MathJax_Preview">P(\bm{\bar{C}})</code><script type="math/tex">P(\bm{\bar{C}})</script> can be calculated as a sum over all the operators in the coset: <code class="MathJax_Preview">P(\bm{\bar{C}}) = \sum_{\bm{C} \in \bm{\bar{C}}} P(\bm{C})</code><script type="math/tex">P(\bm{\bar{C}}) = \sum_{\bm{C} \in \bm{\bar{C}}} P(\bm{C})</script>.</p>

<p>Solving this problem exactly is computationally very hard, as it requires calculating a sum over an exponential number of terms (in the size of the lattice). But for the surface code, it can be approximated very well using <a href="https://arxiv.org/abs/2101.04125">tensor network decoders</a>, which have a complexity of <code class="MathJax_Preview">O(n \chi^3)</code><script type="math/tex">O(n \chi^3)</script> (up to some logarithmic factor), with <code class="MathJax_Preview">n</code><script type="math/tex">n</script> the number of qubits and <code class="MathJax_Preview">\chi</code><script type="math/tex">\chi</script> a parameter quantifying the degree of approximation of the decoder (corresponding to the bound dimension of the tensor network). The main downside of this decoder is that it generalizes poorly to the case of imperfect syndrome measurements. In this case, measurements need to be repeated in time, leading to a 3D decoding problem that tensor networks cannot solve efficiently at the moment.</p>

<p>As discussed in my <a href="/blog/2023-03-28-stabilizer-formalism-3/">stabilizer decoding post</a>, the maximum-likelihood decoding problem can also be approximated by solving for the error with the highest probability, instead of the whole coset. Assuming i.i.d. noise, finding the error with the highest probability is equivalent to finding the smallest error that fits the syndrome. In the case of the surface code, this corresponds to matching the excitations with chains of minimum weight.</p>

<p>As it happens, this is completely equivalent to solving a famous graph problem, known as <a href="https://en.wikipedia.org/wiki/Maximum_weight_matching"><strong>minimum-weight perfect matching</strong></a>! This problem can be expressed as matching all the vertices of a weighted graph (with an even number of vertices), such that the total weight is minimized. In our case, the graph is constructed as a complete graph with a vertex for each excitation. The weight of each edge between two vertices is then given by the Manhattan distance between the two corresponding excitations. For instance, let’s consider the following decoding problem:</p>

<!-- <div id="surface-code-matching" style="display: block; margin: auto; width: 400px; height: 400px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-matching';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 5,
        Ly: 5,
        Lz: 5,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.toggleStabilizer(gui.code.stabilizerMap[[2, 0]], true);
    gui.code.toggleStabilizer(gui.code.stabilizerMap[[2, 4]], true);
    gui.code.toggleStabilizer(gui.code.stabilizerMap[[6, 4]], true);
    gui.code.toggleStabilizer(gui.code.stabilizerMap[[8, 8]], true);

    drawImage(gui, id, true);
</script> -->

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-matching.png" height="350"><img src="/assets/img/blog/surface-code/surface-code-matching.png" height="350"></hy-img>

</p>

<p>The associated graph is then the following:</p>

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/matching-graph.png" height="200"><img src="/assets/img/blog/surface-code/matching-graph.png" height="200"></hy-img>

</p>

<p>By enumerating all the possible matchings, you can quickly see that the one of minimum weight links vertices 1 and 2, and 3 and 4, with a total weight of 5:</p>

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/matching-graph-solution.png" height="200"><img src="/assets/img/blog/surface-code/matching-graph-solution.png" height="200"></hy-img>

</p>

<p>From there, we can deduce our decoding solution:</p>

<!-- <div id="surface-code-decoding-solution" style="display: block; margin: auto; width: 400px; height: 400px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    let id = 'surface-code-decoding-solution';

    const params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 5,
        Ly: 5,
        Lz: 5,
        rotated: false
    };

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([2, 1], 'X');
    gui.code.insertError([2, 3], 'X');
    gui.code.insertError([7, 4], 'X');
    gui.code.insertError([8, 5], 'X');
    gui.code.insertError([8, 7], 'X');

    drawImage(gui, id, true);
</script> -->

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-decoding-solution.png" height="350"><img src="/assets/img/blog/surface-code/surface-code-decoding-solution.png" height="350"></hy-img>

</p>

<p>It happens that minimum-weight perfect-matching can be solved in polynomial time using the <a href="https://en.wikipedia.org/wiki/Blossom_algorithm">Blossom algorithm</a>, which has a worst-case complexity of <code class="MathJax_Preview">O(n^3)</code><script type="math/tex">O(n^3)</script>. While this complexity might seem quite high, a <a href="https://arxiv.org/abs/2303.15933">recent modification</a> of the Blossom algorithm, proposed by Oscar Higgott and Craig Gidney, seems to have an average complexity of <code class="MathJax_Preview">O(n)</code><script type="math/tex">O(n)</script>. It also generalizes very well to the imperfect syndrome case, making it one of the best decoders out there in terms of trade-off between speed and performance (the performance will be reviewed when talking about thresholds in the last section of the post).</p>

<p>You can play with the matching decoder in the following visualization<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup>:</p>

<div style="text-align: center; margin-bottom: 10px; color: gray; font-size: 15px">
    Click on edges to add
    <select id="select-surface-code-decoding-error-type">
        <option value="x">X errors</option>
        <option value="z">Z errors</option>
    </select>
</div>

<div id="surface-code-decoding-insert-errors" style="margin: auto; display: block; max-width: 350px; height: 350px">
</div>

<div style="text-align: center; margin-bottom: 20px; font-size: 15px">
    <button id="button-surface-code-decoding-decode">Decode</button>
    <button id="button-surface-code-decoding-reset">Remove all errors</button>
</div>

<script type="module">
    import { Interface } from 'https://gui.quantumcodes.io/js/gui.js'

    let params = {
        dimension: 2,
        codeName: 'Toric 2D',
        Lx: 4,
        Ly: 4,
        Lz: 4,
        decoder: 'Matching',
        rotated: false
    };

    let gui = new Interface(params, {}, keycode, 'https://gui.quantumcodes.io', 'surface-code-decoding-insert-errors');

    await gui.init();

    let button1 = document.getElementById('button-surface-code-decoding-decode');
    button1.onclick = () => gui.decode();

    let button2 = document.getElementById('button-surface-code-decoding-reset');
    button2.onclick = () => gui.removeAllErrors();

    let selectErrorType = document.getElementById('select-surface-code-decoding-error-type');
    selectErrorType.onchange = function() {
        if (selectErrorType.value == 'x') {
            gui.keycode['x-error'] = 0;
            gui.keycode['z-error'] = -1;
            gui.params.errorModel = 'Pure X';
        }
        else {
            gui.keycode['x-error'] = -1;
            gui.keycode['z-error'] = 0;
            gui.params.errorModel = 'Pure Z';
        }
    }
</script>

<p>There are many other surface code decoders out there with their own pros and cons, such as <a href="https://arxiv.org/abs/1709.06218">union-find</a>, <a href="https://arxiv.org/abs/1811.12456">neural network-based decoders</a>, <a href="https://arxiv.org/abs/2005.07016">belief propagation</a>, etc. Describing them all in detail is out of scope for this blog post, but I hope to write a separate post one day dedicated to decoding. I also haven’t talked much about the decoding problem for imperfect syndrome, which I also leave for a separate blog post.</p>

<p>Let’s now answer a question that you might have been wondering this whole time: how the hell do we implement a toric lattice in practice? While it’s in principle possible to implement an actual torus experimentally (for example with <a href="https://www.nature.com/articles/s41586-018-0450-2/figures/2">cold atoms</a>), it is impractical for many quantum computing architecture. Fortunately, there exists a purely planar version of the surface code, that we will discuss now!</p>

<h2 id="surface-code-with-open-boundaries">Surface code with open boundaries</h2>

<p>Consider the following version of the surface code, where vertex stabilizers on the top and bottom boundaries, and plaquette stabilizers on the left and right boundaries, are now supported on three qubits instead of four:</p>

<div style="text-align: center; margin-bottom: 0px; color: gray; font-size: 15px">
    Click on edges to add
    <select id="select-planar-code-error-type">
        <option value="x">X errors</option>
        <option value="z">Z errors</option>
    </select>
</div>

<div id="planar-code-lattice" style="margin: auto; display: block; max-width: 450px; height: 450px">
</div>

<div style="text-align: center; margin-bottom: 20px; font-size: 15px">
    <button id="button-planar-code-random">Insert random errors</button>
    <button id="button-planar-code-reset">Remove all errors</button>
</div>

<script type="module">
    import { Interface } from 'https://gui.quantumcodes.io/js/gui.js'

    let id = 'planar-code-lattice';

    const params = {
        dimension: 2,
        codeName: 'Planar 2D',
        Lx: 5,
        Ly: 5,
        Lz: 5,
        rotated: false
    };

    let gui = new Interface(params, {}, keycode, 'https://gui.quantumcodes.io', 'planar-code-lattice');

    let button1 = document.getElementById('button-planar-code-random');
    button1.onclick = () => gui.addRandomErrors();

    let button2 = document.getElementById('button-planar-code-reset');
    button2.onclick = () => gui.removeAllErrors();

    let selectErrorType = document.getElementById('select-planar-code-error-type');
    selectErrorType.onchange = function() {
        if (selectErrorType.value == 'x') {
            gui.keycode['x-error'] = 0;
            gui.keycode['z-error'] = -1;
            gui.params.errorModel = 'Pure X';
        }
        else {
            gui.keycode['x-error'] = -1;
            gui.keycode['z-error'] = 0;
            gui.params.errorModel = 'Pure Z';
        }
    }

    await gui.init()
</script>

<p>We call the top and bottom boundaries <strong>smooth boundaries</strong>, and the left and right boundaries <strong>rough boundaries</strong>. Feel free to play with this lattice and try to figure out what the main differences are, compared to the toric code. In particular, can you identify the logical operators of this code? How many equivalent classes, or logical qubits, can you spot?</p>

<p>The first difference to notice is that excitations can now be created at the boundary!</p>

<!-- <div id="planar-code-boundary-errors" style="margin: auto; display: block; width: 450px; height: 450px">
</div>

<script type="module">
    import { Interface } from 'http://127.0.0.1:5001/js/gui.js'

    const params = {
        dimension: 2,
        codeName: 'Planar 2D',
        Lx: 5,
        Ly: 5,
        Lz: 5,
        rotated: false
    };

    let id = 'planar-code-boundary-errors';

    let gui = new Interface(params, {}, {}, 'http://127.0.0.1:5001', id);

    await gui.init()
    gui.code.insertError([1, 2], 'X');
    gui.code.insertError([3, 2], 'X');
    gui.code.insertError([7, 8], 'Z');
    gui.code.insertError([7, 6], 'Z');

    drawImage(gui, id, true);
</script> -->

<p style="text-align:center;">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/planar-code-boundary-errors.png"><img src="/assets/img/blog/surface-code/planar-code-boundary-errors.png"></hy-img>

</p>

<p>In this example, a vertex excitation is created on the rough boundary, and a plaquette excitation is created on the smooth boundary. You can see that excitations don’t have to come in pairs anymore! This poses a slight issue when decoding using minimum-weight perfect matching, but this can easily be overcome by adding some new boundary nodes to the matching graph.</p>

<p>More importantly, we can observe that vertex excitations can only be created or annihilated at the rough boundaries, and plaquette excitations only at the smooth boundaries. This means that <code class="MathJax_Preview">X</code><script type="math/tex">X</script> logicals have to join the rough boundaries, and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> logicals have to join the smooth boundaries. This is illustrated in the following figure, where we can see that there is no “vertical” <code class="MathJax_Preview">X</code><script type="math/tex">X</script> logical or “horizontal” <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> logical.</p>

<p>Therefore, there are only two equivalence classes of logicals for each error type: the strings that join opposite boundaries, and the trivial loops. As a consequence, this non-periodic version of the surface code, also called <strong>planar code</strong>, only encodes a single qubit. It is a <code class="MathJax_Preview">[[2L^2 - 2L + 1, 1, L]]</code><script type="math/tex">[[2L^2 - 2L + 1, 1, L]]</script>-code. While we have lost one qubit compared to the toric version, the fact that it can be laid out on a 2D surface makes it much more practical.</p>

<h2 id="a-more-compact-version-the-rotated-surface-code">A more compact version: the rotated surface code</h2>

<p>If you have started looking at the surface code literature, you might have noticed that people often use a different representation, which looks roughly like the following:</p>

<div style="text-align: center; margin-bottom: 0px; color: gray; font-size: 15px">
    Click on vertices to add
    <select id="select-rectified-code-error-type">
        <option value="x">X errors</option>
        <option value="z">Z errors</option>
    </select>
</div>

<div id="surface-code-rectified-picture" style="margin: auto; display: block; max-width: 450px; height: 450px">
</div>

<div style="text-align: center; margin-bottom: 20px; font-size: 15px">
    <button id="button-rectified-code-random">Insert random errors</button>
    <button id="button-rectified-code-reset">Remove all errors</button>
</div>

<script type="module">
    import { Interface } from 'https://gui.quantumcodes.io/js/gui.js'

    let id = 'surface-code-rectified-picture';

    const params = {
        dimension: 2,
        codeName: 'Planar 2D',
        Lx: 5,
        Ly: 5,
        Lz: 5,
        rotated: true
    };

    let gui = new Interface(params, {}, keycode, 'https://gui.quantumcodes.io', id);

    let button1 = document.getElementById('button-rectified-code-random');
    button1.onclick = () => gui.addRandomErrors();

    let button2 = document.getElementById('button-rectified-code-reset');
    button2.onclick = () => gui.removeAllErrors();

    let selectErrorType = document.getElementById('select-rectified-code-error-type');
    selectErrorType.onchange = function() {
        if (selectErrorType.value == 'x') {
            gui.keycode['x-error'] = 0;
            gui.keycode['z-error'] = -1;
            gui.params.errorModel = 'Pure X';
        }
        else {
            gui.keycode['x-error'] = -1;
            gui.keycode['z-error'] = 0;
            gui.params.errorModel = 'Pure Z';
        }
    }

    await gui.init()
</script>

<p>In this representation, qubits are on the vertices, and all the stabilizers are on the plaquette. Feel free to play with this lattice to understand what’s going on.</p>

<p>It happens that this lattice represents exactly the planar code that we saw before! Here are the two lattices on top of each other:</p>

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-both-pictures.png"><img src="/assets/img/blog/surface-code/surface-code-both-pictures.png"></hy-img>

</p>

<p>The idea is to turn every edge of the original representation into a vertex, each vertex into yellow face, and each face into a rose face. As a result, both vertices and plaquettes become rotated squares, and qubits become vertices. This representation is called the <a href="https://en.wikipedia.org/wiki/Rectification_(geometry)"><strong>rectified lattice</strong></a>.</p>

<p>One advantage of this representation is that it allows to come up with a different, more compact, version of the surface code. The idea is to take to following central piece of the rectified lattice:</p>

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/surface-code-rotated-construction.png"><img src="/assets/img/blog/surface-code/surface-code-rotated-construction.png"></hy-img>

</p>

<p>We then rotate it and add a few boundary stabilizers. This gives the following code, called the <strong>rotated surface code</strong>:</p>

<div style="text-align: center; margin-bottom: 0px; color: gray; font-size: 15px">
    Click on vertices to add
    <select id="select-rotated-code-error-type">
        <option value="x">X errors</option>
        <option value="z">Z errors</option>
    </select>
</div>

<div id="rotated-surface-code" style="margin: auto; display: block; max-width: 450px; height: 450px">
</div>

<div style="text-align: center; margin-bottom: 20px; font-size: 15px">
    <button id="button-rotated-code-random">Insert random errors</button>
    <button id="button-rotated-code-reset">Remove all errors</button>
</div>

<script type="module">
    import { Interface } from 'https://gui.quantumcodes.io/js/gui.js'

    const params = {
        dimension: 2,
        codeName: 'Rotated Planar 2D',
        Lx: 5,
        Ly: 5,
        Lz: 5,
        rotated: true
    };

    let gui = new Interface(params, {}, keycode, 'https://gui.quantumcodes.io', 'rotated-surface-code');

    let button1 = document.getElementById('button-rotated-code-random');
    button1.onclick = () => gui.addRandomErrors();

    let button2 = document.getElementById('button-rotated-code-reset');
    button2.onclick = () => gui.removeAllErrors();

    let selectErrorType = document.getElementById('select-rotated-code-error-type');
    selectErrorType.onchange = function() {
        if (selectErrorType.value == 'x') {
            gui.keycode['x-error'] = 0;
            gui.keycode['z-error'] = -1;
            gui.params.errorModel = 'Pure X';
        }
        else {
            gui.keycode['x-error'] = -1;
            gui.keycode['z-error'] = 0;
            gui.params.errorModel = 'Pure Z';
        }
    }

    gui.init()
</script>

<p>As always, feel free to familiarize yourself with this new code by playing with it on the visualization. You should be able to see that it also encodes a single logical qubit, and has a distance of <code class="MathJax_Preview">L</code><script type="math/tex">L</script>. However, this time, the number of physical qubits is exactly <code class="MathJax_Preview">L^2</code><script type="math/tex">L^2</script>. The rotated surface code is therefore a <code class="MathJax_Preview">[[L^2, 1, L]]</code><script type="math/tex">[[L^2, 1, L]]</script>-code, which is a factor two improvement in the overhead compared to the original surface code. This version of the surface code is therefore the preferred one to realize experimentally. For instance, its two smallest instances, the <code class="MathJax_Preview">[[9,1,3]]</code><script type="math/tex">[[9,1,3]]</script> code and the <code class="MathJax_Preview">[[16,1,4]]</code><script type="math/tex">[[16,1,4]]</script> code are the ones recently realized by the Google lab.</p>

<p>When considering a code family such as the surface code, the <code class="MathJax_Preview">[[n,k,d]]</code><script type="math/tex">[[n,k,d]]</script> parameters only give part of the story. Another very important characteristics of a code family is its set of thresholds.</p>

<h2 id="thresholds-of-the-surface-code">Thresholds of the surface code</h2>

<p>The <strong>threshold</strong> of a code family for a given noise model and decoder is the maximal physical error rate <code class="MathJax_Preview">p_{th}</code><script type="math/tex">p_{th}</script> such that for all <code class="MathJax_Preview">p &lt; p_{th}</code><script type="math/tex">% <![CDATA[
p < p_{th} %]]></script>, increasing the code size decreases the logical error rate. The threshold is typically calculated numerically using plots that look like the following:</p>

<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/threshold-example.png" height="400"><img src="/assets/img/blog/surface-code/threshold-example.png" height="400"></hy-img>

</p>

<p>To make this figure, codes with distance <code class="MathJax_Preview">10,20,30</code><script type="math/tex">10,20,30</script> are simulated under noise channel with varying physical error rate. Errors are then decoded, and logical errors are enumerated. We can see that above <code class="MathJax_Preview">p_{th} \approx 15.5\%</code><script type="math/tex">p_{th} \approx 15.5\%</script>, increasing the code distance increases the logical error rate, while below <code class="MathJax_Preview">p_{th}</code><script type="math/tex">p_{th}</script>, the logical error rate decreases with the code distance.</p>

<p>So what is the threshold of the surface code? First of all, very importantly, there isn’t a single threshold for the surface code: it highly depends on which noise channel and which decoder we are using. Let’s start by discussing noise models.</p>

<p>We often make the distinction between three types of noise models:</p>
<ul>
  <li>The <strong>code-capacity</strong> model, in which errors can occur on all the physical qubits of the code, but measurements are assumed to be perfect.</li>
  <li>The <strong>phenomenological</strong> noise model, in which each stabilizer measurement can also fail with a fixed probability.</li>
  <li>The <strong>circuit-level</strong> noise model, in which the circuits to prepare the code and extract the syndrome are considered, and errors are assumed to occur with a certain probability after each physical gate.</li>
</ul>

<p>The code-capacity threshold is the easiest to estimate, both in terms of implementation time and computational time, and allows to get a rough idea of the performance of a given code or decoder. The phenomenological threshold gets us closer to the true threshold value and can be useful when comparing decoders that deal with measurement errors in interesting ways (such as single-shot decoders). Finally, circuit-level thresholds are the most realistic ones and approximate the most accurately the actual noise level that experimentalists need to reach to make error correction work with a given code. While circuit-level thresholds have been considered very hard to estimate for a long time, mainly due to the lack of very fast noisy Clifford circuit simulators, recent tools such as <a href="https://github.com/quantumlib/Stim">Stim</a> have made those simulations much less cumbersome.</p>

<p>For each of those three models, we also need to specify the distribution of <code class="MathJax_Preview">X</code><script type="math/tex">X</script>, <code class="MathJax_Preview">Y</code><script type="math/tex">Y</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup>. There are two very common choices here. The first is the depolarizing noise model, in which those three Paulis are assumed to occur with the same probability. Since <code class="MathJax_Preview">Y</code><script type="math/tex">Y</script> is made of <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script>, it means that <code class="MathJax_Preview">P(Y)=P(X,Z) \neq P(X)P(Z)</code><script type="math/tex">P(Y)=P(X,Z) \neq P(X)P(Z)</script>, or in other words, <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> are correlated. Another noise model is the independent <code class="MathJax_Preview">X/Z</code><script type="math/tex">X/Z</script> model, in which <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> are independent and occur with the same probability. The probability of getting <code class="MathJax_Preview">Y</code><script type="math/tex">Y</script> errors is fixed as <code class="MathJax_Preview">P(Y)=P(X)P(Z)=P(X)^2</code><script type="math/tex">P(Y)=P(X)P(Z)=P(X)^2</script> and is therefore lower than for depolarizing noise.</p>

<p>Regarding the decoders, we will consider two of them here for simplicity: the maximum-likelihood decoder, and the matching decoder. As it happens, the code-capacity threshold for the maximum likelihood decoder corresponds exactly to the phase transition of a certain statistical mechanics model. This <em>stat mech mapping</em> was established in <a href="https://arxiv.org/abs/quant-ph/0110143">Dennis et al.</a> (a classic of the quantum error correction literature) in 2002. For the surface code subjected to independent <code class="MathJax_Preview">X/Z</code><script type="math/tex">X/Z</script> errors, the equivalent stat mech model is the random-bond Ising model, whose phase transition had just been calculated at that time. They were therefore able to give this first surface code threshold without doing any simulation themselves!</p>

<p>We are now ready to give the actual threshold values for the surface code! Here is a table with the code-capacity thresholds of the different noise models and decoder discussed previously:</p>

<table style="margin: auto; width: 60%; text-align: center; margin-bottom: 1em">
<th>
    <td>Maximum-likelihood</td>
    <td>Matching</td>
</th>
<tr>
    <td>Depolarizing noise</td>
    <td><a href="https://arxiv.org/abs/1202.1852">18.9%</a></td>
    <td><a href="https://arxiv.org/abs/0905.0531">15.5%</a></td>
</tr>
<tr>
    <td>Independent noise</td>
    <td><a href="https://arxiv.org/abs/quant-ph/0110143">10.9%</a></td>
    <td><a href="https://arxiv.org/abs/quant-ph/0110143">10.5%</a></td>
</tr>
</table>
<p class="figure">Table 1: Code-capacity thresholds of the surface code</p>

<p>For phenomenological and circuit-level noise, I am only aware of some matching decoder thresholds under depolarizing noise. For phenomenological noise, we have a threshold of about <a href="https://arxiv.org/abs/1907.02554"><code class="MathJax_Preview">3\%</code><script type="math/tex">3\%</script></a>. For circuit-level noise, the threshold goes down to about <a href="https://arxiv.org/abs/0905.0531"><code class="MathJax_Preview">1\%</code><script type="math/tex">1\%</script></a>, which is often the cited value for “the threshold of the surface code”.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this post, we have defined the surface code and its different variants (toric, planar, rotated) and tried to understand its most important properties visually. We have seen that it encodes one or two logical qubits depending on the boundary conditions, and has a distance scaling as <code class="MathJax_Preview">\sqrt{N}</code><script type="math/tex">\sqrt{N}</script>. Stabilizers can be thought as trivial (or contractible) loops on the underlying manifold, while the logical <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> operators are the non-trivial loops going around the torus or joining the boundaries, drawing a connection between topology and codes. We have also studied the decoding problem for the surface code and how minimum-weight perfect matching can be used for this purpose. Finally, I have introduced the notion of error-correction threshold and given its value for different decoders and noise models.</p>

<p>The surface code is by far one of the most studied codes of the quantum error-correction literature and there is a lot more to say about it! I haven’t told you how to deal with measurement errors, how to prepare the code and measure the syndrome using quantum circuits, how to run logical gates on it, how to generalize it to different lattices and dimensions, how to make precise the connection with topology, etc. The surface code is also a stepping stone to understand more complicated codes, from the color code (the second most famous family of 2D codes) to hypergraph product codes and all the way to good LDPC codes. Now that you are equipped with the stabilizer formalism and have a good grasp of the surface code, the tree of possible learning trajectories has suddenly acquired many branches, and I hope to cover as many of those in subsequent blog posts!</p>

<p>In the meantime, one direct follow-up from this post is <a href="https://dom-kufel.github.io/blog/2023-04-15-toric_code-intro/">Dominik Kufel’s post</a> on the condensed matter aspects of the toric code, where you will learn about the connection between codes and Hamiltonians, why <em>excitations</em> are called excitations and can be thought of as quasi-particles called <em>anyons</em>, what the state of the surface code looks like and how it provides an example of topological phase of matter. This connection is crucial to learn for any practicing quantum error-correcter, as it is used extensively in the literature and allows to understand many computational aspects of the surface code (how to make gates by braiding anyons, why the circuit to prepare the surface code has polynomial size, etc.). So go read his post!</p>

<h2 id="solution-of-the-exercise">Solution of the exercise</h2>

<p class="message"><strong>Exercise 1</strong>: What is the equivalence class of the following (purple) loop? <a href="#loops-on-a-smooth-manifold">(Back to section)</a></p>
<p style="text-align:center; margin-top: 2em; margin-bottom: 2em">
    <hy-img root-margin="511px" src="/assets/img/blog/surface-code/torus-exercise.png" height="200"><img src="/assets/img/blog/surface-code/torus-exercise.png" height="200"></hy-img>

</p>
<p class="message"><strong>Correction</strong>: The loops goes once around the middle hole, and three times around the hole forming the inside of the donut. Therefore, it belongs to coset labelled by <code class="MathJax_Preview">(1,3)</code><script type="math/tex">(1,3)</script>.</p>

<p class="message"><strong>Exercise 2</strong>: What are the <code class="MathJax_Preview">[[n,k,d]]</code><script type="math/tex">[[n,k,d]]</script> parameters of a surface code with lattice size <code class="MathJax_Preview">L</code><script type="math/tex">L</script>? <a href="#loops-on-the-surface-code">(Back to section)</a></p>

<p class="message"><strong>Correction</strong>: Since there are <code class="MathJax_Preview">L^2</code><script type="math/tex">L^2</script> horizontal and <code class="MathJax_Preview">L^2</code><script type="math/tex">L^2</script> vertical edges, we have <code class="MathJax_Preview">n=2L^2</code><script type="math/tex">n=2L^2</script>. Then, we saw that there are exactly two non-equivalent types of logical operators, meaning that there are <code class="MathJax_Preview">k=2</code><script type="math/tex">k=2</script> qubits. Finally, the distance is the minimum size of a logical operator, which in our case is <code class="MathJax_Preview">d=L</code><script type="math/tex">d=L</script>. Therefore, the surface code is a <code class="MathJax_Preview">[[2L^2, 2, L]]</code><script type="math/tex">[[2L^2, 2, L]]</script>-code.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>I tend to use the names <em>surface code</em> and <em>toric code</em> interchangeably. Some people use <em>surface code</em> to talk about the open-boundary version and <em>toric code</em> to talk about the periodic-boundary one, but this is not a universal convention, and the name <em>planar code</em> is also often used to talk about the open-boundary version. <a href="#fnref:1" class="reversefootnote">&#x21a9;&#xfe0e;</a></p>
    </li>
    <li id="fn:2">
      <p>The final version of this embedding is just a few lines of Javascript, which use <a href="gui.quantumcodes.io">https://gui.quantumcodes.io</a> as an API. So if <strong>you</strong> would like to embed some codes (both 2D and 3D) in your website, feel free to contact me and I’ll give you the instructions to do it (I might add an official tutorial in the PanQEC documentation later). <a href="#fnref:2" class="reversefootnote">&#x21a9;&#xfe0e;</a></p>
    </li>
    <li id="fn:3">
      <p>For the interested reader, the rigorous definition is that two loops are equivalent if there exists a <strong>homotopy</strong> between them. More precisely, we can define a loop as a continuous map <code class="MathJax_Preview">\ell: S^1 \rightarrow \mathcal{M}</code><script type="math/tex">\ell: S^1 \rightarrow \mathcal{M}</script> (an embedding of the circle onto the manifold). A homotopy between two loops <code class="MathJax_Preview">\ell_1, \ell_2</code><script type="math/tex">\ell_1, \ell_2</script> is then a continuous function <code class="MathJax_Preview">L:S^1 \times [0,1] \rightarrow \mathcal{M}</code><script type="math/tex">L:S^1 \times [0,1] \rightarrow \mathcal{M}</script> such that <code class="MathJax_Preview">L(\cdot, 0)=\ell_1</code><script type="math/tex">L(\cdot, 0)=\ell_1</script> and <code class="MathJax_Preview">L(\cdot, 1)=\ell_2</code><script type="math/tex">L(\cdot, 1)=\ell_2</script>. In other words, each <code class="MathJax_Preview">L(\cdot, t)</code><script type="math/tex">L(\cdot, t)</script> for <code class="MathJax_Preview">t \in [0,1]</code><script type="math/tex">t \in [0,1]</script> defines a different loop on the path from <code class="MathJax_Preview">\ell_1</code><script type="math/tex">\ell_1</script> to <code class="MathJax_Preview">\ell_2</code><script type="math/tex">\ell_2</script>. The equivalence relation defined here is called <strong>homotopy equivalence</strong>, and is one of the most important notions of equivalence in topology. <a href="#fnref:3" class="reversefootnote">&#x21a9;&#xfe0e;</a></p>
    </li>
    <li id="fn:4">
      <p>This other notion of equivalence is called <strong>homological equivalence</strong>. Technically, two loops are homologically-equivalent if they can be seen as the boundary of a higher-dimensional object (in our case, the boundary of some plaquettes). In particular, trivial loops are the ones that are themselves boundaries of some objects (they are equivalent to the zero loop) and non-trivial loops are the ones that cannot be seen as boundaries. While the notion of homotopy is more powerful in general (it gives more information about a topological manifold), homology classes are usually simpler to calculate and are the right topological invariants for many practical applications. I will try to dedicate a post to the notion homology and its applications in quantum error correction. <a href="#fnref:4" class="reversefootnote">&#x21a9;&#xfe0e;</a></p>
    </li>
    <li id="fn:5">
      <p><a href="https://arxiv.org/abs/2303.13723">Rotor codes</a> are example of such continuous-variable codes. <a href="#fnref:5" class="reversefootnote">&#x21a9;&#xfe0e;</a></p>
    </li>
    <li id="fn:6">
      <p>The backend is using <a href="https://github.com/oscarhiggott/PyMatching">PyMatching</a>, Oscar Higgott’s fast implementation of minimum-weight perfect matching. <a href="#fnref:6" class="reversefootnote">&#x21a9;&#xfe0e;</a></p>
    </li>
    <li id="fn:7">
      <p>We assume here that we have a Pauli error model. The reasons for this choice are actually quite technical and I hope to write a post about it one day. In the meantime, you can have a look at Section 10.3 of Nielsen &amp; Chuang to get an idea of the argument. <a href="#fnref:7" class="reversefootnote">&#x21a9;&#xfe0e;</a></p>
    </li>
  </ol>
</div>

  
</article>


<hr class="dingbat related" />




  
     



  

  
  

  
    




  

  
  


  
<aside class="comments related" role="complementary">
  <h2 class="hr">Comments</h2>
  

<div id="disqus_thread"></div>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script>!function(w, d) {
  if (d.getElementById("disqus_thread")) {
    if (w.DISQUS) {
      w.DISQUS.reset({
        reload: true,
        config() {
          this.page.url = w.location.href;
          this.page.title = d.title;
        },
      });
    } else {
      w.disqus_config = function disqusConfig() {
        this.page.url = w.location.href;
        this.page.title = d.title;
      };
      w.loadJSDeferred(d.getElementById("_hrefDisqus").href + '/embed.js');
    }
  }
}(window, document);</script>


</aside>


  
<footer role="contentinfo">
  <hr/>
  
    <p><small class="copyright">© 2020. All rights reserved.
</small></p>
  
  
  <p><small>Powered by <a class="external" href="https://hydejack.com/">Hydejack</a> v<span id="_version">8.5.2</span></small></p>
  <hr class="sr-only"/>
</footer>


</main>

    <hy-drawer
  class=""
  align="left"
  threshold="10"
  touch-events
  prevent-default
>
  <header id="_sidebar" class="sidebar" role="banner">
    
    <div class="sidebar-bg sidebar-overlay" style="background-color:rgb(25,55,71);background-image:url(/assets/img/sidebar-bg.jpg)"></div>

    <div class="sidebar-sticky">
      <div class="sidebar-about">
        
          <a class="no-hover" href="/" tabindex="-1">
            <img src="/assets/icons/icon.png" class="avatar" alt="Arthur Pesah" data-ignore />
          </a>
        
        <h2 class="h1"><a href="/">Arthur Pesah</a></h2>
        
        
          <p class="">
            Researcher in quantum computing. PhD student at UCL (London)

          </p>
        
      </div>

      <nav class="sidebar-nav heading" role="navigation">
        <span class="sr-only">Navigation:</span>
<ul>
  
    
      
      <li>
        <a
          id="_navigation"
          href="/"
          class="sidebar-nav-item active"
          
        >
          Intro
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/blog/"
          class="sidebar-nav-item active"
          
        >
          Blog
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/publications/"
          class="sidebar-nav-item"
          
        >
          Publications
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/writing/"
          class="sidebar-nav-item"
          
        >
          Other writings
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/talks/"
          class="sidebar-nav-item"
          
        >
          Talks
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/animations/"
          class="sidebar-nav-item"
          
        >
          Animations
        </a>
      </li>
    
  
</ul>

      </nav>

      

      <div class="sidebar-social">
        <span class="sr-only">Social:</span>
<ul>
  
    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://twitter.com/artix41" title="Twitter" class="no-mark-external">
      <span class="icon-twitter"></span>
      <span class="sr-only">Twitter</span>
    </a>
  </li>


    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://github.com/artix41" title="GitHub" class="no-mark-external">
      <span class="icon-github"></span>
      <span class="sr-only">GitHub</span>
    </a>
  </li>


    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://www.linkedin.com/in/arthur-pesah" title="LinkedIn" class="no-mark-external">
      <span class="icon-linkedin2"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  </li>


    
  
</ul>

      </div>
    </div>
  </header>
</hy-drawer>
<hr class="sr-only" hidden />

  
</hy-push-state>

<!--[if gt IE 10]><!---->

  <script nomodule>!function(){var e=document.createElement("script");if(!("noModule"in e)&&"onbeforeload"in e){var t=!1;document.addEventListener("beforeload",function(n){if(n.target===e)t=!0;else if(!n.target.hasAttribute("nomodule")||!t)return;n.preventDefault()},!0),e.type="module",e.src=".",document.head.appendChild(e),e.remove()}}();
</script>
  <script type="module" src="/assets/js/hydejack-8.5.2.js"></script>
  <script nomodule src="/assets/js/hydejack-legacy-8.5.2.js" defer></script>
  

  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-3K1GWGLHP0"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-3K1GWGLHP0');
  </script>



<!--<![endif]-->




<h2 class="sr-only" hidden>Templates (for web app):</h2>

<template id="_animation-template" hidden>
  <div class="animation-main fixed-top">
    <div class="content">
      <div class="page"></div>
    </div>
  </div>
</template>

<template id="_loading-template" hidden>
  <div class="loading nav-btn fr">
    <span class="sr-only">Loading…</span>
    <span class="icon-cog"></span>
  </div>
</template>

<template id="_error-template" hidden>
  <div class="page">
    <h1 class="page-title">Error</h1>
    
    
    <p class="lead">
      Sorry, an error occurred while loading <a class="this-link" href=""></a>.

    </p>
  </div>
</template>

<template id="_forward-template" hidden>
  <button id="_forward" class="forward nav-btn no-hover fl">
    <span class="sr-only">Forward</span>
    <span class="icon-arrow-right2"></span>
  </button>
</template>

<template id="_back-template" hidden>
  <button id="_back" class="back nav-btn no-hover fl">
    <span class="sr-only">Back</span>
    <span class="icon-arrow-left2"></span>
  </button>
</template>

<template id="_permalink-template" hidden>
  <a href="#" class="permalink">
    <span class="sr-only">Permalink</span>
    <span class="icon-link"></span>
  </a>
</template>




</body>
</html>
