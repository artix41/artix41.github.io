<!DOCTYPE html>
<html lang="en"><!--
 __  __                __                                     __
/\ \/\ \              /\ \             __                    /\ \
\ \ \_\ \   __  __    \_\ \      __   /\_\      __       ___ \ \ \/'\
 \ \  _  \ /\ \/\ \   /'_` \   /'__`\ \/\ \   /'__`\    /'___\\ \ , <
  \ \ \ \ \\ \ \_\ \ /\ \L\ \ /\  __/  \ \ \ /\ \L\.\_ /\ \__/ \ \ \\`\
   \ \_\ \_\\/`____ \\ \___,_\\ \____\ _\ \ \\ \__/.\_\\ \____\ \ \_\ \_\
    \/_/\/_/ `/___/> \\/__,_ / \/____//\ \_\ \\/__/\/_/ \/____/  \/_/\/_/
                /\___/                \ \____/
                \/__/                  \/___/

Powered by Hydejack v8.5.2 <https://hydejack.com/>
-->











<head>
  



<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">




  
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>The stabilizer trilogy I — Stabilizer codes | Arthur Pesah</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="The stabilizer trilogy I — Stabilizer codes" />
<meta name="author" content="Arthur Pesah" />
<meta property="og:locale" content="en" />
<meta name="description" content="Research blog" />
<meta property="og:description" content="Research blog" />
<link rel="canonical" href="https://arthurpesah.me/blog/2023-01-31-stabilizer-formalism-1/" />
<meta property="og:url" content="https://arthurpesah.me/blog/2023-01-31-stabilizer-formalism-1/" />
<meta property="og:site_name" content="Arthur Pesah" />
<meta property="og:image" content="https://arthurpesah.me/assets/img/blog/stabilizer-formalism-1/thumbnail.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-01-31T00:00:00-07:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://arthurpesah.me/assets/img/blog/stabilizer-formalism-1/thumbnail.png" />
<meta property="twitter:title" content="The stabilizer trilogy I — Stabilizer codes" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Arthur Pesah"},"dateModified":"2023-01-31T00:00:00-07:00","datePublished":"2023-01-31T00:00:00-07:00","description":"Research blog","headline":"The stabilizer trilogy I — Stabilizer codes","image":"https://arthurpesah.me/assets/img/blog/stabilizer-formalism-1/thumbnail.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://arthurpesah.me/blog/2023-01-31-stabilizer-formalism-1/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://arthurpesah.me/assets/icons/icon.png"},"name":"Arthur Pesah"},"url":"https://arthurpesah.me/blog/2023-01-31-stabilizer-formalism-1/"}</script>
<!-- End Jekyll SEO tag -->


  

  
    <meta name="keywords" content="quantum computing,machine learning,research,papers,qml,quantum ML">
  


<meta name="mobile-web-app-capable" content="yes">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Arthur Pesah">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<meta name="application-name" content="Arthur Pesah">
<meta name="msapplication-config" content="/assets/ieconfig.xml">


<meta name="theme-color" content="rgb(25,55,71)">


<meta name="generator" content="Hydejack v8.5.2" />

<link type="application/atom+xml" rel="alternate" href="https://arthurpesah.me/feed.xml" title="Arthur Pesah" />



<link rel="alternate" href="https://arthurpesah.me/blog/2023-01-31-stabilizer-formalism-1/" hreflang="en">

<link rel="shortcut icon" href="/assets/icons/favicon.ico">
<link rel="apple-touch-icon" href="/assets/icons/icon.png">

<link rel="manifest" href="/assets/manifest.json">


  <link rel="dns-prefetch" href="https://fonts.googleapis.com">
  <link rel="dns-prefetch" href="https://fonts.gstatic.com">


  <link rel="dns-prefetch" href="https://www.google-analytics.com">



<link rel="dns-prefetch" href="/" id="_baseURL">
<link rel="dns-prefetch" href="/sw.js" id="_hrefSW">
<link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.js" id="_hrefKatexJS">
<link rel="dns-prefetch" href="/assets/bower_components/katex/dist/katex.min.css" id="_hrefKatexCSS">
<link rel="dns-prefetch" href="/assets/bower_components/katex/dist/contrib/copy-tex.min.js" id="_hrefKatexCopyJS">
<link rel="dns-prefetch" href="/assets/bower_components/katex/dist/contrib/copy-tex.min.css" id="_hrefKatexCopyCSS">
<link rel="dns-prefetch" href="/assets/img/swipe.svg" id="_hrefSwipeSVG">



<link rel="dns-prefetch" href="https://arthurpesah.disqus.com" id="_hrefDisqus">


<script>
!function(e,t){"use strict";function n(e,t,n,r){e.addEventListener?e.addEventListener(t,n,r):e.attachEvent?e.attachEvent("on"+t,n):e["on"+t]=n}e.loadJS=function(e,r){var o=t.createElement("script");o.src=e,r&&n(o,"load",r,{once:!0});var a=t.scripts[0];return a.parentNode.insertBefore(o,a),o},e._loaded=!1,e.loadJSDeferred=function(r,o){function a(){e._loaded=!0,o&&n(c,"load",o,{once:!0});var r=t.scripts[0];r.parentNode.insertBefore(c,r)}var c=t.createElement("script");return c.src=r,e._loaded?a():n(e,"load",a,{once:!0}),c},e.setRel=e.setRelStylesheet=function(e){function r(){this.rel="stylesheet"}var o=t.getElementById(e);n(o,"load",r,{once:!0})}}(window,document);
;
!function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this);
;
!function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this);
;
!function(w, d) {
  w._noPushState = false;
  w._noDrawer = false;
}(window, document);
</script>

<!--[if gt IE 8]><!---->











  <link rel="stylesheet" href="/assets/css/hydejack-8.5.2.css">
  <link rel="stylesheet" href="/assets/icomoon/style.css">
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:400|Noto+Sans:400,400i,700,700i&display=swap">
  


  <style id="_pageStyle">

.content a:not(.btn){color:#4fb1ba;border-color:rgba(79,177,186,0.2)}.content a:not(.btn):hover{border-color:#4fb1ba}:focus{outline-color:#4fb1ba !important}.btn-primary{color:#fff;background-color:#4fb1ba;border-color:#4fb1ba}.btn-primary:focus,.btn-primary.focus,.form-control:focus,.form-control.focus{box-shadow:0 0 0 3px rgba(79,177,186,0.5)}.btn-primary:hover,.btn-primary.hover{color:#fff;background-color:#409ba3;border-color:#409ba3}.btn-primary:disabled,.btn-primary.disabled{color:#fff;background-color:#4fb1ba;border-color:#4fb1ba}.btn-primary:active,.btn-primary.active{color:#fff;background-color:#409ba3;border-color:#409ba3}::selection{color:#fff;background:#4fb1ba}::-moz-selection{color:#fff;background:#4fb1ba}

</style>


<!--<![endif]-->




</head>

<body class="no-color-transition">
  <div id="_navbar" class="navbar fixed-top">
  <div class="content">
    <div class="nav-btn-bar">
      <span class="sr-only">Jump to:</span>
      <a id="_menu" class="nav-btn no-hover fl" href="#_navigation">
        <span class="sr-only">Navigation</span>
        <span class="icon-menu"></span>
      </a>
      <!-- <a id="_search" class="nav-btn no-hover fl" href="#_search">
        <span class="sr-only">Search</span>
        <span class="icon-search"></span>
      </a>
      <form action="https://duckduckgo.com/" method="GET">
        <div class="form-group fr">
          <label class="sr-only" for="_search">Search</label>
          <input id="_search" name="q" class="form-control" type="search" />
        </div>
        <input type="hidden" name="q" value="site:hydejack.com" />
        <input type="hidden" name="ia" value="web" />
      </form> -->
    </div>
  </div>
</div>
<hr class="sr-only" hidden />


<hy-push-state
  replace-ids="_main"
  link-selector="a[href]:not([href*='/assets/']):not(.external):not(.no-push-state)"
  duration="250"
  script-selector="script:not([type^='math/tex'])"
  prefetch
>
  
    <main
  id="_main"
  class="content fade-in layout-post"
  role="main"
  data-color="rgb(79,177,186)"
  data-theme-color="rgb(25,55,71)"
  
    data-image="/assets/img/sidebar-bg.jpg"
    data-overlay
  
  >
  




<article id="post-blog-stabilizer-formalism-1" class="page post mb6" role="article">
  <header>
    <h1 class="post-title">
      
        The stabilizer trilogy I — Stabilizer codes
      
    </h1>

    <p class="post-date heading">
      
      <time datetime="2023-01-31T00:00:00-07:00">31 Jan 2023</time>
      
      
      
      
<!--      









in <a href="/blog/" class="flip-title">Blog</a>
-->
      









on <a href="/tag-quantum-computing/" class="flip-title">Quantum Computing</a>

    </p>

    
    
      <div class="img lead sixteen-nine">
        


  <test2></test2>
  <hy-img root-margin="511px" src="/assets/img/blog/stabilizer-formalism-1/thumbnail.png"
    
    alt="The stabilizer trilogy I — Stabilizer codes"><img src="/assets/img/blog/stabilizer-formalism-1/thumbnail.png"
    
    alt="The stabilizer trilogy I — Stabilizer codes"></hy-img>



      </div>
      
    

    



  


  </header>

  
    <p>Now that you know <a href="/blog/2022-05-21-classical-error-correction/">all you need to know about classical error correction</a>, the time has finally come to learn how to correct those damn errors that keep sabotaging your quantum computer! The key tool, introduced by Daniel Gottesman in <a href="https://thesis.library.caltech.edu/2900/2/THESIS.pdf">his landmark 1997 PhD thesis</a> is the stabilizer formalism.
The same way most classical codes fall into the linear code category, almost all the quantum codes you will encounter can be classified as stabilizer codes. And for a good reason: stabilizer codes are simply the quantum generalization of linear codes!
Your beloved parity checks will turn into stabilizers, a set of commuting measurements controlling the parity of your qubits in different bases.
Parity-check matrices and Tanner graphs will get slightly bigger and more constrained. But apart from that, if you’re more or less comfortable with the notions discussed in the last post, going quantum shouldn’t give you too much trouble.</p>

<p>So, what’s the plan? To make the content of this post a bit more digestible, I’ve decided to divide it into three parts: the stabilizer trilogy.
In the first part, we will start by motivating the need for the stabilizer formalism, using the quantum repetition code and Shor’s code as examples. We will then be ready to formally define stabilizer codes and one of its most important families, the CSS codes.
To illustrate our construction, we will end the post by introducing a simple code that really exemplifies the stabilizer and CSS construction: the Steane code. Finally, in case you need it, I’ve put some reminders on the manipulation of Pauli operators in the appendix.</p>

<p>In the second part of this series, we will look more deeply into the properties of stabilizer codes. In particular, we will introduce the notion of logical operator, and see how it can be used to derive the parameters of stabilizer codes. In the last part, we will learn how to generalize parity-check matrices and Tanner graphs to the quantum setting. This formulation can be used to express the decoding problem formally and to implement quantum code simulation in practice.</p>

<p>This trilogy should give you all you need to start exploring the quantum error correction literature. And with all those tools in our hand, we will finally be ready to study one of the most popular quantum code: the surface code! So hang in there, have a good read, and I assure you the journey will be worth it!</p>

<h2 id="motivation-a-new-lens-on-the-quantum-repetition-code">Motivation: a new lens on the quantum repetition code</h2>

<p>To understand the challenges in building quantum codes, let’s look back at our good ol’ quantum repetition code (introduced in the <a href="/blog/2022-01-25-intro-qec-1/">first post</a> of this series), with our new error correction knowledge.  As a reminder, the quantum repetition code is defined as the encoding of a single-qubit logical state <code class="MathJax_Preview">\vert \psi \rangle_L = a \vert 0 \rangle_L + b \vert 1 \rangle_L</code><script type="math/tex">\vert \psi \rangle_L = a \vert 0 \rangle_L + b \vert 1 \rangle_L</script> as a 3-qubit physical state:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
\vert \psi \rangle = a \vert 000 \rangle + b \vert 111 \rangle
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
\vert \psi \rangle = a \vert 000 \rangle + b \vert 111 \rangle
\end{aligned}</script>

<p>We define the <strong>codespace</strong> of our code as the space of all the states that can be written as above (for any <code class="MathJax_Preview">a,b</code><script type="math/tex">a,b</script>).
Let’s see how errors affect the codespace.
As we saw in the first post, quantum noise comes into two flavours: <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors, also known as bit flips, and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors, also known as phase flips.
Let’s focus on <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors first.
If an <code class="MathJax_Preview">X</code><script type="math/tex">X</script> error occurs on the first qubit, the state is transformed into</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
\vert \widetilde{\psi} \rangle = X_1 \vert \psi \rangle = a \vert 100 \rangle + b \vert 011 \rangle
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
\vert \widetilde{\psi} \rangle = X_1 \vert \psi \rangle = a \vert 100 \rangle + b \vert 011 \rangle
\end{aligned}</script>

<p>In the classical repetition code, errors such as this one could be detected by reading the message and seeing that it is neither <code class="MathJax_Preview">000</code><script type="math/tex">000</script> or <code class="MathJax_Preview">111</code><script type="math/tex">111</script>, or in other words, it is not a codeword.
Decoding would then consist of taking a majority vote on the three bits.</p>

<p>However, in the quantum case, “reading the message” would collapse the state and ruin any further computation we might want to do on this state.
To make error detection work, let’s remember that there is another technique to detect errors on linear codes (including the repetition code), that we saw in the last post: we can look at the parity checks of the code! For the classical repetition codes, those parity checks measured the parity of all the pairs of bits. If some of the checks had an odd parity, it meant that an error had occurred, and depending on which pairs had a violated parity-check equation, we could then decode any single bit-flip error.</p>

<p>And that’s where the magic comes in: those parity checks can be measured quantumly without collapsing the state!
First, you might wonder what “parity” means for our state, given that we have a superposition of two computational basis elements in the codespace.
However, it’s easy to verify that it is actually well-defined. Consider the state <code class="MathJax_Preview">\vert \psi \rangle</code><script type="math/tex">\vert \psi \rangle</script> subjected to any number of bit-flip errors. Choose one of the two elements of the superposition. Look at the parity of a pair of qubits. This parity will be the same if you had chosen the other element of the superposition. This is due to the fact that bit flips are always applied simultaneously on both parts of the superposition.</p>

<p>Now, how do we measure this parity? We can simply measure the observable <code class="MathJax_Preview">Z_i Z_j</code><script type="math/tex">Z_i Z_j</script>.
Indeed, <code class="MathJax_Preview">\vert \psi \rangle</code><script type="math/tex">\vert \psi \rangle</script> is an eigenstate of <code class="MathJax_Preview">Z_i Z_j</code><script type="math/tex">Z_i Z_j</script>, and remains so when bit-flip errors are applied to the state.
For instance, <code class="MathJax_Preview">Z_1 Z_2 \vert \psi \rangle = \vert \psi \rangle</code><script type="math/tex">Z_1 Z_2 \vert \psi \rangle = \vert \psi \rangle</script>, meaning that measuring <code class="MathJax_Preview">Z_1 Z_2</code><script type="math/tex">Z_1 Z_2</script> on the error-free state will give <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script>.
On the other hand, <code class="MathJax_Preview">Z_1 Z_2 \vert \widetilde{\psi} \rangle = Z_1 Z_2 X_1 \vert \psi \rangle = - X_1 Z_1 Z_2 \vert \psi \rangle = -\vert \widetilde{\psi} \rangle</code><script type="math/tex">Z_1 Z_2 \vert \widetilde{\psi} \rangle = Z_1 Z_2 X_1 \vert \psi \rangle = - X_1 Z_1 Z_2 \vert \psi \rangle = -\vert \widetilde{\psi} \rangle</script>, so measuring this operator when a bit-flip has occurred on the first qubit gives <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script> (if this manipulation of Pauli operators is not straightforward to you, feel free to read the <a href="2023-01-21-stabilizer-formalism-1/#appendix-handling-pauli-operators-with-ease">Appendix</a> on Pauli operators and come back).
Checking those calculations on your own, and for other examples of bit-flip errors, should convince you that measuring <code class="MathJax_Preview">Z_i Z_j</code><script type="math/tex">Z_i Z_j</script> gives you exactly the parity between the qubits <code class="MathJax_Preview">i</code><script type="math/tex">i</script> and <code class="MathJax_Preview">j</code><script type="math/tex">j</script>. In general, the result of measuring those operators is exactly like the syndrome we introduced in the previous post: we get <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> when a parity-check equation is satisfied, and <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script> when it is not. As an example of how to measure those parity checks, the circuit to measure <code class="MathJax_Preview">Z_1 Z_2</code><script type="math/tex">Z_1 Z_2</script> is given below:</p>

<p class="figure"><hy-img root-margin="511px" src="/assets/img/blog/stabilizer-formalism-1/repetition-code-circuit.png" alt=""><img src="/assets/img/blog/stabilizer-formalism-1/repetition-code-circuit.png" alt=""></hy-img>
</p>

<p>So, what have we done so far? We have found a set of operators <code class="MathJax_Preview">\{Z_i Z_j\}</code><script type="math/tex">\{Z_i Z_j\}</script> such that:</p>
<ol>
  <li>Our error-free state is a simultaneous <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> eigenstate of all those operators</li>
  <li>Single and two-qubit <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors anti-commute with some of them, allowing the detection and correction of <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors.</li>
</ol>

<p>We will soon call those operators “stabilizers”, and study their general properties.
But first—you might have been wondering all this time—what about <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors?
As it happens, they are actually undetectable by our code.
For instance, if a <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> error were to occur on the first qubit of the state <code class="MathJax_Preview">\vert \psi \rangle</code><script type="math/tex">\vert \psi \rangle</script>, we would get the state</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
\vert \widetilde{\psi} \rangle = Z_1 \vert \psi \rangle = a \vert 000 \rangle - b \vert 111 \rangle
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
\vert \widetilde{\psi} \rangle = Z_1 \vert \psi \rangle = a \vert 000 \rangle - b \vert 111 \rangle
\end{aligned}</script>

<p>This is still in the codespace of our code! Therefore, we have no way to detect this error:
<code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors are <strong>logical errors</strong>.
We define the <strong>distance</strong> of a code as the smallest Pauli error that maps the codespace to itself,
or in other words, the smallest logical error. Since a single <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> error in the quantum repetition code
is undetectable, it means that the distance of the code is <code class="MathJax_Preview">1</code><script type="math/tex">1</script>.
Denoting <code class="MathJax_Preview">n</code><script type="math/tex">n</script> the number of physical qubits of a code, <code class="MathJax_Preview">k</code><script type="math/tex">k</script> the number of logical qubits it encodes,
and <code class="MathJax_Preview">d</code><script type="math/tex">d</script> its distance, we say that the repetition code is an <code class="MathJax_Preview">[[n,k,d]]=[[n,1,1]]</code><script type="math/tex">[[n,k,d]]=[[n,1,1]]</script>-code.
Note the use of double brackets, a common convention used to distinguish quantum from classical codes.</p>

<p>So what do we do from there? Taking inspiration from the quantum repetition code, let’s try to build
our first code that can detect both <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors: Shor’s code.</p>

<h2 id="our-first-truly-quantum-code-shors-code">Our first truly quantum code: Shor’s code</h2>

<p>To understand the idea behind Shor’s code, let’s first see how we could design a repetition code that only protects information against <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors, instead of <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors. Can you see what modification of the repetition code would be required?</p>

<p>The idea is to simply use a different basis for the codewords. Indeed, replacing <code class="MathJax_Preview">\{\vert 000\rangle, \vert 111\rangle\}</code><script type="math/tex">\{\vert 000\rangle, \vert 111\rangle\}</script> by <code class="MathJax_Preview">\{\vert +++\rangle, \vert ---\rangle\}</code><script type="math/tex">\{\vert +++\rangle, \vert ---\rangle\}</script>, and the parity-check measurements <code class="MathJax_Preview">\{Z_i Z_j\}</code><script type="math/tex">\{Z_i Z_j\}</script> by <code class="MathJax_Preview">\{X_i X_j\}</code><script type="math/tex">\{X_i X_j\}</script>, we obtain a code that can correct any single-qubit <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> error.</p>

<p>The trick found by Peter Shor is to combine those two codes using a process called <strong>concatenation</strong>. It consists of encoding the logical qubits of one code using a second code. In our case, we can encode the logical qubits of the <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script>-basis repetition code into the <code class="MathJax_Preview">X</code><script type="math/tex">X</script>-basis repetition code. This defines the 9-qubit Shor’s code, made of the following codewords</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
\vert 0 \rangle_{L_2} = \vert + \rangle_{L_1} \otimes \vert + \rangle_{L_1} \otimes \vert + \rangle_{L_1} = \frac{1}{2^{3/2}} \left(\vert 000 \rangle + \vert 111 \rangle \right) \left(\vert 000 \rangle + \vert 111 \rangle \right) \left(\vert 000 \rangle + \vert 111 \rangle \right) \\
\vert 1 \rangle_{L_2} = \vert - \rangle_{L_1} \otimes \vert - \rangle_{L_1} \otimes \vert - \rangle_{L_1} = \frac{1}{2^{3/2}} \left(\vert 000 \rangle - \vert 111 \rangle \right) \left(\vert 000 \rangle - \vert 111 \rangle \right) \left(\vert 000 \rangle - \vert 111 \rangle \right)
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
\vert 0 \rangle_{L_2} = \vert + \rangle_{L_1} \otimes \vert + \rangle_{L_1} \otimes \vert + \rangle_{L_1} = \frac{1}{2^{3/2}} \left(\vert 000 \rangle + \vert 111 \rangle \right) \left(\vert 000 \rangle + \vert 111 \rangle \right) \left(\vert 000 \rangle + \vert 111 \rangle \right) \\
\vert 1 \rangle_{L_2} = \vert - \rangle_{L_1} \otimes \vert - \rangle_{L_1} \otimes \vert - \rangle_{L_1} = \frac{1}{2^{3/2}} \left(\vert 000 \rangle - \vert 111 \rangle \right) \left(\vert 000 \rangle - \vert 111 \rangle \right) \left(\vert 000 \rangle - \vert 111 \rangle \right)
\end{aligned}</script>

<p>where <code class="MathJax_Preview">\vert \cdot \rangle_{L_1}</code><script type="math/tex">\vert \cdot \rangle_{L_1}</script> refers to logical qubits after the first encoding, for which <code class="MathJax_Preview">\vert 0 \rangle_{L_1}=\vert 000 \rangle</code><script type="math/tex">\vert 0 \rangle_{L_1}=\vert 000 \rangle</script>, and <code class="MathJax_Preview">\vert \cdot \rangle_{L_2}</code><script type="math/tex">\vert \cdot \rangle_{L_2}</script> refers to logical qubits after the second encoding, for which <code class="MathJax_Preview">\vert 0 \rangle_{L_2}=\vert +++ \rangle_{L_1}</code><script type="math/tex">\vert 0 \rangle_{L_2}=\vert +++ \rangle_{L_1}</script>.</p>

<p>Now, if an <code class="MathJax_Preview">X</code><script type="math/tex">X</script> error occurs on any of the 9 qubits, we will be able to correct it by measuring <code class="MathJax_Preview">Z_i Z_{j}</code><script type="math/tex">Z_i Z_{j}</script> on all the qubits <code class="MathJax_Preview">i</code><script type="math/tex">i</script> and <code class="MathJax_Preview">j</code><script type="math/tex">j</script> of the same block. Indeed, you can check that in the absence of error, we have</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
Z_i Z_j \vert \psi \rangle_{L_2} = \vert \psi \rangle_{L_2}
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
Z_i Z_j \vert \psi \rangle_{L_2} = \vert \psi \rangle_{L_2}
\end{aligned}</script>

<p>with <code class="MathJax_Preview">\vert \psi \rangle_{L_2} = a \vert 0 \rangle_{L_2} + b \vert 1 \rangle_{L_2}</code><script type="math/tex">\vert \psi \rangle_{L_2} = a \vert 0 \rangle_{L_2} + b \vert 1 \rangle_{L_2}</script>.
This means that measuring those operators will give the result <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script>.</p>

<p>On the other hand, let’s say we have an <code class="MathJax_Preview">X</code><script type="math/tex">X</script> error on the fourth qubit of the logical zero state. It would result in the state:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
X_4 \vert 0 \rangle_{L_2} = \frac{1}{2^{3/2}} \left(\vert 000 \rangle + \vert 111 \rangle \right) \left(\vert 100 \rangle + \vert 011 \rangle \right) \left(\vert 000 \rangle + \vert 111 \rangle \right)
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
X_4 \vert 0 \rangle_{L_2} = \frac{1}{2^{3/2}} \left(\vert 000 \rangle + \vert 111 \rangle \right) \left(\vert 100 \rangle + \vert 011 \rangle \right) \left(\vert 000 \rangle + \vert 111 \rangle \right)
\end{aligned}</script>

<p>The odd parity between qubit 4 and qubits 5 and 6, detected by measuring <code class="MathJax_Preview">Z_4 Z_5</code><script type="math/tex">Z_4 Z_5</script> and <code class="MathJax_Preview">Z_5 Z_6</code><script type="math/tex">Z_5 Z_6</script>, tells us that the <code class="MathJax_Preview">X</code><script type="math/tex">X</script> error occurred on qubit <code class="MathJax_Preview">4</code><script type="math/tex">4</script>. We can therefore correct this error, and more generally any other single-qubit <code class="MathJax_Preview">X</code><script type="math/tex">X</script> error, by analyzing the result of the <code class="MathJax_Preview">Z_i Z_j</code><script type="math/tex">Z_i Z_j</script> measurements.</p>

<p>Let’s now focus our attention to <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors. Let’s remember that for the Z-basis repetition code, the operator <code class="MathJax_Preview">\overline{X}=XXX</code><script type="math/tex">\overline{X}=XXX</script> is a logical Pauli <code class="MathJax_Preview">X</code><script type="math/tex">X</script> operator, turning <code class="MathJax_Preview">\vert 0 \rangle_{L_1}</code><script type="math/tex">\vert 0 \rangle_{L_1}</script> into <code class="MathJax_Preview">\vert 1 \rangle_{L_1}</code><script type="math/tex">\vert 1 \rangle_{L_1}</script>. Let’s write <code class="MathJax_Preview">\overline{X_1}=X_1 X_2 X_3</code><script type="math/tex">\overline{X_1}=X_1 X_2 X_3</script>, <code class="MathJax_Preview">\overline{X_2}=X_4 X_5 X_6</code><script type="math/tex">\overline{X_2}=X_4 X_5 X_6</script> and <code class="MathJax_Preview">\overline{X_3}=X_7 X_8 X_9</code><script type="math/tex">\overline{X_3}=X_7 X_8 X_9</script>.</p>

<p>To detect <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors, we can measure the parity <code class="MathJax_Preview">\overline{X}_i \overline{X}_{j}</code><script type="math/tex">\overline{X}_i \overline{X}_{j}</script> for all <code class="MathJax_Preview">i,j \in \{1,2,3\}</code><script type="math/tex">i,j \in \{1,2,3\}</script>, <code class="MathJax_Preview">i \neq j</code><script type="math/tex">i \neq j</script>. Indeed, you can verify explicitly that we have</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
\overline{X_i} \overline{X_j} \vert \psi \rangle_{L_2} = \vert \psi \rangle_{L_2}
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
\overline{X_i} \overline{X_j} \vert \psi \rangle_{L_2} = \vert \psi \rangle_{L_2}
\end{aligned}</script>

<p>for all <code class="MathJax_Preview">i,j</code><script type="math/tex">i,j</script>. Moreover, if a <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> error occurs, for example on the fourth qubit of the logical zero state, we would get:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
Z_4 \vert 0 \rangle_{L_2} = \vert +-+ \rangle_{L_1} = \frac{1}{2^{3/2}} \left(\vert 000 \rangle + \vert 111 \rangle \right) \left(\vert 000 \rangle - \vert 111 \rangle \right) \left(\vert 000 \rangle + \vert 111 \rangle \right)
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
Z_4 \vert 0 \rangle_{L_2} = \vert +-+ \rangle_{L_1} = \frac{1}{2^{3/2}} \left(\vert 000 \rangle + \vert 111 \rangle \right) \left(\vert 000 \rangle - \vert 111 \rangle \right) \left(\vert 000 \rangle + \vert 111 \rangle \right)
\end{aligned}</script>

<p>The odd parity between blocks <code class="MathJax_Preview">1</code><script type="math/tex">1</script> and <code class="MathJax_Preview">2</code><script type="math/tex">2</script> and blocks <code class="MathJax_Preview">2</code><script type="math/tex">2</script> and <code class="MathJax_Preview">3</code><script type="math/tex">3</script> can be detected using the operator <code class="MathJax_Preview">\overline{X_1} \overline{X_2} = X_1 X_2 X_3 X_4 X_5 X_6</code><script type="math/tex">\overline{X_1} \overline{X_2} = X_1 X_2 X_3 X_4 X_5 X_6</script> and <code class="MathJax_Preview">\overline{X_2} \overline{X_3} = X_4 X_5 X_6 X_7 X_8 X_9</code><script type="math/tex">\overline{X_2} \overline{X_3} = X_4 X_5 X_6 X_7 X_8 X_9</script>. You can check that explicitly by applying those operators to <code class="MathJax_Preview">Z_4 \vert 0 \rangle_{L_2}</code><script type="math/tex">Z_4 \vert 0 \rangle_{L_2}</script> and showing for instance that</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
\overline{X_1} \overline{X_2} Z_4 \vert 0 \rangle_{L_2} = - Z_4 \vert 0 \rangle_{L_2}
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
\overline{X_1} \overline{X_2} Z_4 \vert 0 \rangle_{L_2} = - Z_4 \vert 0 \rangle_{L_2}
\end{aligned}</script>

<p>meaning that the result of measuring <code class="MathJax_Preview">\overline{X_1} \overline{X_2}</code><script type="math/tex">\overline{X_1} \overline{X_2}</script> will be <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script>. Similarly, the result of measuring <code class="MathJax_Preview">\overline{X_2} \overline{X_3}</code><script type="math/tex">\overline{X_2} \overline{X_3}</script> will be <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script>. However, note that we would have obtained the exact same measurement result if the <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> error had occurred on qubit <code class="MathJax_Preview">5</code><script type="math/tex">5</script> or qubit <code class="MathJax_Preview">6</code><script type="math/tex">6</script>. That’s our first example of <strong>error degeneracy</strong>: different errors causing the same syndrome. How do we decide where to apply our correction then? The answer is that it doesn’t matter: we can choose either of the three middle qubits. To see why, let’s look at what happens if we apply <code class="MathJax_Preview">Z_5</code><script type="math/tex">Z_5</script> to a state affected by the error <code class="MathJax_Preview">Z_4</code><script type="math/tex">Z_4</script>:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
Z_5 Z_4 \vert \psi \rangle_{L_2} = \vert \psi \rangle_{L_2}
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
Z_5 Z_4 \vert \psi \rangle_{L_2} = \vert \psi \rangle_{L_2}
\end{aligned}</script>

<p>It gets us back to the original state! The reason is that any state in the codespace is a +1 eigenstate of <code class="MathJax_Preview">Z_5 Z_4</code><script type="math/tex">Z_5 Z_4</script> (as we saw when looking at <code class="MathJax_Preview">X</code><script type="math/tex">X</script> error detection). The same phenomenon would have happened if we had applied <code class="MathJax_Preview">Z_6</code><script type="math/tex">Z_6</script>, and therefore we can correct the <code class="MathJax_Preview">Z_4</code><script type="math/tex">Z_4</script> error by applying a <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> operator on any of the three middle qubits. More generally, any single-qubit <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> error can be corrected by analyzing the result of the <code class="MathJax_Preview">\overline{X}_i \overline{X}_{j}</code><script type="math/tex">\overline{X}_i \overline{X}_{j}</script> measurements. This trick for dealing with error degeneracies is preponderant in quantum error correction, and we will see the most general version of it when looking at decoding stabilizer codes (in the next post).</p>

<p>So our code is able to detect and correct any single-qubit error. But what about errors of higher weight? Or in other words, what is the distance of Shor’s code (i.e. the smallest undetectable errors)? Since this is a perfect exercise to see if you’ve understood this code, I leave this question as an exercise!</p>

<p class="message"><strong>Exercise</strong>: show that Shor’s code has a distance of <code class="MathJax_Preview">d=3</code><script type="math/tex">d=3</script>. <br />
<em>(<strong>Hint</strong>: find a weight-3 error, made of either <code class="MathJax_Preview">X</code><script type="math/tex">X</script> or <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> elements, that applies a bit-flip or phase-flip to the logical state of the code)</em></p>

<p>In summary, we have found a <code class="MathJax_Preview">[[9,1,3]]</code><script type="math/tex">[[9,1,3]]</script> quantum code that can detect both <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors by measuring a set of operators <code class="MathJax_Preview">\{ Z_i Z_j \}</code><script type="math/tex">\{ Z_i Z_j \}</script> and <code class="MathJax_Preview">\{\overline{X_i} \overline{X_j} \}</code><script type="math/tex">\{\overline{X_i} \overline{X_j} \}</script>. This means that error-free states (i.e. codewords) are a common <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> eigenstate of those operators, while states subjected to weight-1 and weight-2 errors are <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script> eigenstates of some of those operators, allowing us to detect those errors. With this example in mind, we are now finally ready to delve into the stabilizer formalism!</p>

<h2 id="stabilizer-formalism-first-definitions">Stabilizer formalism: first definitions</h2>

<p>The stabilizer formalism allows us to generalize the ideas above in order to come up with new quantum codes and study their properties. The main idea is to change our perspective from states (or codewords) to operators, similarly to the way we defined classical linear codes using parity-check matrices. But generalizing parity-check operators in the quantum setting requires a bit of care. Let’s see how it works.</p>

<p>First, let me outline the general idea of this section.
As we saw with Shor’s code, errors in a quantum code can be detected by measuring a certain set of operators, generalizing the parity checks of classical codes.
Those operators are called <strong>stabilizers</strong> and have a certain number of properties: they have eigenvalues <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> and <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script>, they all commute (the order of measurement doesn’t matter), etc.
Moreover, any codeword is a common <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> eigenstate of all the stabilizers, i.e. measuring any stabilizer on an error-free state gives the value <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> and does not disturb the state.</p>

<p>The goal is to go backward: given any set of stabilizers, does it define a code?
As found out by Daniel Gottesman, the answer is yes, and this simple fact has been foundational for quantum error correction, allowing us to find codes by searching for stabilizers with good properties.
Let us now introduce the formalism behind this brilliant idea.</p>

<p>The n-qubit <strong>Pauli group</strong> <code class="MathJax_Preview">\mathcal{P}_n</code><script type="math/tex">\mathcal{P}_n</script> is the set of all Pauli operators on <code class="MathJax_Preview">n</code><script type="math/tex">n</script> qubits, with the usual matrix multiplication as the group operation, that is:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
\mathcal{P}_n=\{ \omega P_1 \otimes \ldots \otimes P_n : P_i \in \{I,X,Y,Z \}, \omega \in \{1,-1,i,-i\}\}
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
\mathcal{P}_n=\{ \omega P_1 \otimes \ldots \otimes P_n : P_i \in \{I,X,Y,Z \}, \omega \in \{1,-1,i,-i\}\}
\end{aligned}</script>

<p>Note that the phase factor is included in order for this set to be close under the group operation.</p>

<p>We can now define a <strong>stabilizer group</strong> as an abelian subgroup of the Pauli group that does not contain <code class="MathJax_Preview">-I</code><script type="math/tex">-I</script>.
Let’s slowly break that down.
First, the stabilizer group is a subgroup of the Pauli group, meaning that every element is a Pauli operator, and has in consequence eigenvalues <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> and <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script>. It is a group, meaning that the product of any two stabilizers is also a stabilizer.
This group is abelian, meaning that any two stabilizers commute, and can therefore be measured in any order.
Finally, we don’t want <code class="MathJax_Preview">-I</code><script type="math/tex">-I</script> to be included, or equivalently we don’t want any two operators <code class="MathJax_Preview">S</code><script type="math/tex">S</script> and <code class="MathJax_Preview">-S</code><script type="math/tex">-S</script> to be in the same stabilizer group, as it will make sense shortly.</p>

<p>We can now define a <strong>stabilizer code</strong> as the common <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> eigenspace of all the operators in a stabilizer group.
That is, given a stabilizer group <code class="MathJax_Preview">\mathcal{S}</code><script type="math/tex">\mathcal{S}</script>, we define the codespace of a stabilizer code as:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
\mathcal{C}=\{ \vert \psi \rangle : S\vert \psi \rangle = \vert \psi \rangle, \forall S \in \mathcal{S} \}
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
\mathcal{C}=\{ \vert \psi \rangle : S\vert \psi \rangle = \vert \psi \rangle, \forall S \in \mathcal{S} \}
\end{aligned}</script>

<p>This set is well-defined, since by definition all the stabilizers commute, and have therefore some common eigenstates.
Moreover, each stabilizer has at least one <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> eigenvalue (remember that <code class="MathJax_Preview">-I</code><script type="math/tex">-I</script> is not included in the stabilizer group), so there is a common <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> eigenstate of all the stabilizers. Finally, you can notice that <code class="MathJax_Preview">\mathcal{C}</code><script type="math/tex">\mathcal{C}</script> forms a vector space, and therefore defines a valid code.</p>

<p>This one-to-one correspondence between codespaces defined as above and stabilizer groups is the foundation of quantum error correction: instead of the thinking of codes in the state picture (as a vector space of states), we can now think of them in the operator picture (as a stabilizer group). For instance, Shor’s code can either be defined in the state picture, as the codespace <code class="MathJax_Preview">\{a \vert 0 \rangle_{L_2} + b \vert 1 \rangle_{L_2} \}</code><script type="math/tex">\{a \vert 0 \rangle_{L_2} + b \vert 1 \rangle_{L_2} \}</script> (with <code class="MathJax_Preview">\vert 0 \rangle_{L_2}</code><script type="math/tex">\vert 0 \rangle_{L_2}</script> and <code class="MathJax_Preview">\vert 1 \rangle_{L_2}</code><script type="math/tex">\vert 1 \rangle_{L_2}</script> defined in the previous section), or in the operator picture, as the codespace stabilized by <code class="MathJax_Preview">\langle Z_i Z_j, \overline{X_i} \overline{X_j} \rangle</code><script type="math/tex">\langle Z_i Z_j, \overline{X_i} \overline{X_j} \rangle</script> with <code class="MathJax_Preview">i,j</code><script type="math/tex">i,j</script> neighboring physical/logical qubits.</p>

<p>Last but not least, how can we detect and correct errors with a stabilizer code? As we saw with the repetition code and Shor’s code, the idea is to simply measure all the stabilizers, resulting in what is called the <strong>syndrome</strong>. If no error has occurred, the syndrome should consist of <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> for all the stabilizers. If a Pauli error <code class="MathJax_Preview">E</code><script type="math/tex">E</script> has occurred, there are two possibilities for each stabilizer <code class="MathJax_Preview">S</code><script type="math/tex">S</script>: either it commutes or it anticommutes with it. If it commutes, we will measure <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script>:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
SE \vert \psi \rangle = ES \vert \psi \rangle = E \vert \psi \rangle
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
SE \vert \psi \rangle = ES \vert \psi \rangle = E \vert \psi \rangle
\end{aligned}</script>

<p>If it anticommutes, we will measure <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script>:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
SE \vert \psi \rangle = - ES \vert \psi \rangle = - E \vert \psi \rangle
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
SE \vert \psi \rangle = - ES \vert \psi \rangle = - E \vert \psi \rangle
\end{aligned}</script>

<p>To detect <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors, we therefore need stabilizers with some <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> or <code class="MathJax_Preview">Y</code><script type="math/tex">Y</script> operators, while to detect <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors, we need stabilizers with some <code class="MathJax_Preview">X</code><script type="math/tex">X</script> or <code class="MathJax_Preview">Y</code><script type="math/tex">Y</script> operators.</p>

<p>By analyzing the syndrome, it is often possible to correct errors as well. However, one specificity of quantum codes is that we often don’t need to find the exact qubits on which the errors have occurred. What we need is to find a correction operator <code class="MathJax_Preview">C</code><script type="math/tex">C</script> that restores our state, that is:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
C E \vert \psi \rangle = \vert \psi \rangle
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
C E \vert \psi \rangle = \vert \psi \rangle
\end{aligned}</script>

<p>In other words, we want <code class="MathJax_Preview">C E</code><script type="math/tex">C E</script> to be a stabilizer. For instance, in Shor’s code, we saw that if the error <code class="MathJax_Preview">Z_4</code><script type="math/tex">Z_4</script> occurs, we can correct it by using either <code class="MathJax_Preview">Z_4</code><script type="math/tex">Z_4</script>, <code class="MathJax_Preview">Z_5</code><script type="math/tex">Z_5</script> or <code class="MathJax_Preview">Z_6</code><script type="math/tex">Z_6</script> as our correction operator. This was due to <code class="MathJax_Preview">Z_4 Z_4</code><script type="math/tex">Z_4 Z_4</script>, <code class="MathJax_Preview">Z_4 Z_5</code><script type="math/tex">Z_4 Z_5</script> and <code class="MathJax_Preview">Z_4 Z_6</code><script type="math/tex">Z_4 Z_6</script> being stabilizers. Finding the best correction operator is the essence of the <strong>decoding problem</strong>, which we will see in more details in the next post.</p>

<p>So what have we done so far? We have shown that given a stabilizer group, that is a set of commuting Pauli operators that does not contain <code class="MathJax_Preview">-I</code><script type="math/tex">-I</script>, we can construct a quantum code by considering the common +1 eigenspace of all the stabilizers.
When errors occur in this code, moving the state outside of the codespace, they can be detected (and sometimes corrected) by measuring all the stabilizers and checking if some measurements are equal to <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script>.</p>

<p>However, we haven’t yet given any method to construct interesting stabilizer groups. The next section introduces one of the most important family of stabilizer codes, the CSS codes, which will help us to build a new example of quantum code: the quantum version of the Hamming code.</p>

<h2 id="quantum-codes-from-classical-codes-the-css-construction">Quantum codes from classical codes: the CSS construction</h2>

<p>So, how can we construct stabilizer codes? One method is to start from two classical codes: one that will take care of <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors and one that will take care of <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors. As we saw in the previous section, to correct <code class="MathJax_Preview">X</code><script type="math/tex">X</script> errors, we can use stabilizers made of <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> operators, and to correct <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors, we can use stabilizers made of <code class="MathJax_Preview">X</code><script type="math/tex">X</script> operators.</p>

<p>The idea is therefore the following: let’s pick two classical codes that we will call <code class="MathJax_Preview">C_X</code><script type="math/tex">C_X</script> and <code class="MathJax_Preview">C_Z</code><script type="math/tex">C_Z</script>. For each parity check of <code class="MathJax_Preview">C_X</code><script type="math/tex">C_X</script>, supported on bits <code class="MathJax_Preview">b_1,\ldots,b_k</code><script type="math/tex">b_1,\ldots,b_k</script>, add the stabilizer <code class="MathJax_Preview">X_{b_1} \ldots X_{b_k}</code><script type="math/tex">X_{b_1} \ldots X_{b_k}</script> to the stabilizer group. Similarly, for each parity check of <code class="MathJax_Preview">C_Z</code><script type="math/tex">C_Z</script>, supported on bits <code class="MathJax_Preview">b'_1,\ldots,b'_k</code><script type="math/tex">b'_1,\ldots,b'_k</script>, add the stabilizer <code class="MathJax_Preview">Z_{b'_1} \ldots Z_{b'_k}</code><script type="math/tex">Z_{b'_1} \ldots Z_{b'_k}</script> to the stabilizer group.
For the resulting quantum code to be valid, remember that all the stabilizers should commute. While stabilizers of the same Pauli type necessarily commute, it is not obvious that all the <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> stabilizers commute with all the <code class="MathJax_Preview">X</code><script type="math/tex">X</script> stabilizers. For this to be the case, each <code class="MathJax_Preview">X</code><script type="math/tex">X</script> stabilizer should intersect on an even number of qubits with all the <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> stabilizers (see <a href="2023-01-21-stabilizer-formalism-1/#appendix-handling-pauli-operators-with-ease">Appendix</a>).</p>

<p>If this is the case, the resulting quantum code is valid and form what is called a Calderbank-Shor-Steane (CSS) code. More precisely, a <strong>CSS code</strong> is a stabilizer code that can be generated by a set of pure <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and pure <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> stabilizers. For instance, both codes that we have encountered before, Shor’s code and the quantum repetition code, are examples of CSS codes. And so are most of the codes that you will encounter in the literature, making CSS codes one of the most important family of codes.</p>

<p>However, if you try the construction above with some random codes <code class="MathJax_Preview">C_X</code><script type="math/tex">C_X</script> and <code class="MathJax_Preview">C_Z</code><script type="math/tex">C_Z</script> taken from the classical literature, you will find that it is very difficult to pass the commutation criterion. Therefore, more involved methods are needed to construct quantum codes, such as topological constructions or hypergraph products. However, there is on example where our procedure works extremely well: our good old Hamming code!</p>

<h2 id="steane-code-the-quantum-version-of-the-hamming-code">Steane code, the quantum version of the Hamming code</h2>

<p>It’s finally time to illustrate the stabilizer formalism with a concrete example!
If the two previous sections were feeling a bit abstract, this section should hopefully clarify things.</p>

<p>So let’s apply the CSS construction to the Hamming code that we introduced in the <a href="/blog/2022-05-21-classical-error-correction/">previous blog post</a>. As a reminder, the Hamming code is a <code class="MathJax_Preview">[7,4,3]</code><script type="math/tex">[7,4,3]</script>-code defined by the following three parity check equations<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p>

<pre class="MathJax_Preview"><code>\begin{aligned}
    x_1 + x_2 + x_3 + x_4 = 0 \\
    x_2 + x_3 + x_5 + x_6 = 0 \\
    x_3 + x_4 + x_6 + x_7 = 0
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
    x_1 + x_2 + x_3 + x_4 = 0 \\
    x_2 + x_3 + x_5 + x_6 = 0 \\
    x_3 + x_4 + x_6 + x_7 = 0
\end{aligned}</script>

<p>Let’s now apply the CSS construction with <code class="MathJax_Preview">C_X</code><script type="math/tex">C_X</script> and <code class="MathJax_Preview">C_Z</code><script type="math/tex">C_Z</script> two Hamming codes. To <code class="MathJax_Preview">C_X</code><script type="math/tex">C_X</script>, we associate the group <code class="MathJax_Preview">\mathcal{S}_X</code><script type="math/tex">\mathcal{S}_X</script> on 7 qubits defined as:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
    \mathcal{S}_X = \langle X_1 X_2 X_3 X_4, X_2 X_3 X_5 X_6, X_3 X_4 X_6 X_7 \rangle
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
    \mathcal{S}_X = \langle X_1 X_2 X_3 X_4, X_2 X_3 X_5 X_6, X_3 X_4 X_6 X_7 \rangle
\end{aligned}</script>

<p>and to <code class="MathJax_Preview">C_Z</code><script type="math/tex">C_Z</script>, the group <code class="MathJax_Preview">\mathcal{S}_Z</code><script type="math/tex">\mathcal{S}_Z</script> defined as:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
    \mathcal{S}_Z = \langle Z_1 Z_2 Z_3 Z_4, Z_2 Z_3 Z_5 Z_6, Z_3 Z_4 Z_6 Z_7 \rangle
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
    \mathcal{S}_Z = \langle Z_1 Z_2 Z_3 Z_4, Z_2 Z_3 Z_5 Z_6, Z_3 Z_4 Z_6 Z_7 \rangle
\end{aligned}</script>

<p>It is often convenient to visualize stabilizer codes using some graphical representations. Here is how to visualize the stabilizers defined above:</p>

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/stabilizer-formalism-1/steane-code-lattice.png" height="300"><img src="/assets/img/blog/stabilizer-formalism-1/steane-code-lattice.png" height="300"></hy-img>

</p>

<p>In this figure, each vertex (numbered from 1 to 7) represents a qubit, and each coloured face (often called <strong>plaquette</strong> in the literature) supports an <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and a <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> stabilizer. The different plaquette stabilizers are shown explicitly here:</p>

<p class="figure"><hy-img root-margin="511px" src="/assets/img/blog/stabilizer-formalism-1/steane-code-stabilizers.png" alt=""><img src="/assets/img/blog/stabilizer-formalism-1/steane-code-stabilizers.png" alt=""></hy-img>
</p>

<p>From this representation, it is easy to see that each plaquette stabilizer intersects with every other plaquette stabilizers on exactly two qubits, which is an even number. As we discussed earlier, it means that elements of <code class="MathJax_Preview">\mathcal{S}_X</code><script type="math/tex">\mathcal{S}_X</script> and <code class="MathJax_Preview">\mathcal{S}_Z</code><script type="math/tex">\mathcal{S}_Z</script> commute, and we can form a valid code by combining the generators of the two groups. The resulting code is called the <strong>Steane code</strong>, and is an example of <strong>color code</strong> (a very interesting family of codes which would deserve their own blog post).</p>

<p>The Steane code is often considered a promising candidate for near-term quantum error correction and is indeed one of the first codes to have been implemented on a real device (by different teams of ion trappers) <sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>. This is due to its many nice properties: its small size (it only requires <code class="MathJax_Preview">7</code><script type="math/tex">7</script> physical qubits), its 2D locality (it can be built on a 2D lattice without requiring long-range connections to measure the stabilizers), and the presence of many transversal logical gates (a topic for another time). Furthermore, it only requires the measurement of weight-4 stabilizers, as opposed to Shor’s code which requires measuring weight-6 stabilizers. Since errors can happen during the measurement of stabilizers, a good rule of thumb to get well-performing quantum codes is to always try to minimize the weight of its stabilizer generators.</p>

<p>We will study the characteristics of the Steane code in the next post, showing that it is a <code class="MathJax_Preview">[[7,1,3]]</code><script type="math/tex">[[7,1,3]]</script> quantum code. Meanwhile, we can already look at what happens in the presence of single-qubit errors. Since <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors are detected in the same way (using either <code class="MathJax_Preview">X</code><script type="math/tex">X</script> or <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> stabilizers on the plaquettes), we can consider the effect of <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors only, without loss of generality. Below is the observed syndrome for a single <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> error on qubits <code class="MathJax_Preview">1</code><script type="math/tex">1</script> to <code class="MathJax_Preview">3</code><script type="math/tex">3</script>:</p>

<p style="text-align:center;" class="figure">
    <hy-img root-margin="511px" src="/assets/img/blog/stabilizer-formalism-1/steane-code-errors.png"><img src="/assets/img/blog/stabilizer-formalism-1/steane-code-errors.png"></hy-img>

</p>

<p>In this figure, the purple vertices correspond to <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> errors, and the highlighted plaquettes to stabilizer measurements of <code class="MathJax_Preview">-1</code><script type="math/tex">-1</script>.
To obtain this this result, note that a single-qubit <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> error will always anticommute with the <code class="MathJax_Preview">X</code><script type="math/tex">X</script> plaquette it touches (you can easily show this using the property of the appendix).</p>

<p>You can continue this exercise with the remaining single-qubit errors, and you will see that they all lead to a different syndrome.
Therefore, the Steane code can correct any single-qubit error.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this post, we have introduced the most important tool to build and analyze quantum codes: the stabilizer formalism. Starting from a stabilizer group (set of commuting Pauli operators), we found that we can construct a codespace by considering the common <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> eigenspace of its elements. We defined the family of CSS codes, whose stabilizer generators can be split into pure <code class="MathJax_Preview">X</code><script type="math/tex">X</script> and pure <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> elements. We studied a few examples of stabilizer codes: the <code class="MathJax_Preview">[[3,1,1]]</code><script type="math/tex">[[3,1,1]]</script> repetition code, the <code class="MathJax_Preview">[[9,1,3]]</code><script type="math/tex">[[9,1,3]]</script> Shor code, and the <code class="MathJax_Preview">[[7,1,3]]</code><script type="math/tex">[[7,1,3]]</script> Steane code.</p>

<p>In the next post, we will go further in our study of stabilizer codes: we will learn how to find the logical operators, the distance and the number of encoded qubits of a code. The Steane code will continue to serve as our main example throughout the next post.</p>

<p class="message"><strong>Acknowledgment</strong>: Big thanks to Dominik Kufel and Ren Li for their feedbacks on this blog post!</p>

<h2 id="appendix-useful-tricks-to-manipulate-pauli-operators">Appendix: useful tricks to manipulate Pauli operators</h2>

<p>For the discussion that follows, let’s define a Pauli operator as an operator of the form <code class="MathJax_Preview">P_1 \otimes \ldots \otimes P_n</code><script type="math/tex">P_1 \otimes \ldots \otimes P_n</script> with <code class="MathJax_Preview">P_i \in \{I, X, Y, Z\}</code><script type="math/tex">P_i \in \{I, X, Y, Z\}</script> for all <code class="MathJax_Preview">i</code><script type="math/tex">i</script>. As a reminder, here is the definitions of the Pauli matrices <code class="MathJax_Preview">X,Y,Z</code><script type="math/tex">X,Y,Z</script>:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
    X = \left(
        \begin{matrix}
            0 &amp; 1 \\ 1 &amp; 0
        \end{matrix}
    \right), \;
    Y = \left(
        \begin{matrix}
            0 &amp; -i \\ i &amp; 0
        \end{matrix}
    \right), \;
    Z = \left(
        \begin{matrix}
            1 &amp; 0 \\ 0 &amp; -1
        \end{matrix}
    \right) \;
\end{aligned}</code></pre>
<script type="math/tex; mode=display">% <![CDATA[
\begin{aligned}
    X = \left(
        \begin{matrix}
            0 & 1 \\ 1 & 0
        \end{matrix}
    \right), \;
    Y = \left(
        \begin{matrix}
            0 & -i \\ i & 0
        \end{matrix}
    \right), \;
    Z = \left(
        \begin{matrix}
            1 & 0 \\ 0 & -1
        \end{matrix}
    \right) \;
\end{aligned} %]]></script>

<p>We say that two Pauli operators <code class="MathJax_Preview">P</code><script type="math/tex">P</script> and <code class="MathJax_Preview">P'</code><script type="math/tex">P'</script> commute if <code class="MathJax_Preview">P P' = P'P</code><script type="math/tex">P P' = P'P</script>, and anticommute if <code class="MathJax_Preview">P P' = -P' P</code><script type="math/tex">P P' = -P' P</script>. The goal of this section is to prove the following extremely useful fact about Pauli operators:</p>

<p class="message"><strong>Property</strong>: Two Pauli operators <code class="MathJax_Preview">P</code><script type="math/tex">P</script> and <code class="MathJax_Preview">P'</code><script type="math/tex">P'</script> commute if they intersect on an even number of terms with a different Pauli element. Otherwise, they anticommute.</p>

<p>For instance, <code class="MathJax_Preview">X_1 Y_2 Z_3 X_4</code><script type="math/tex">X_1 Y_2 Z_3 X_4</script> and <code class="MathJax_Preview">X_1 Z_4</code><script type="math/tex">X_1 Z_4</script> anticommute: they intersect on qubits <code class="MathJax_Preview">1</code><script type="math/tex">1</script> (with the same Pauli) and <code class="MathJax_Preview">4</code><script type="math/tex">4</script> (with a different Pauli), so only on one qubit with a different Pauli. On the other hand, <code class="MathJax_Preview">X_1 X_2 X_3</code><script type="math/tex">X_1 X_2 X_3</script> and <code class="MathJax_Preview">Z_2 Z_3 Z_4</code><script type="math/tex">Z_2 Z_3 Z_4</script> commute as they intersect on two terms (qubits <code class="MathJax_Preview">2</code><script type="math/tex">2</script> and <code class="MathJax_Preview">3</code><script type="math/tex">3</script>) with a different Pauli.</p>

<p>This property is used all the time in quantum error correction: to check that the stabilizers of a code commute, to see how errors affect the stabilizer measurements, etc. So it’s worth getting comfortable with it early in your QEC journey.</p>

<p>So let’s show this fact. Let <code class="MathJax_Preview">P=P_1 \ldots P_n</code><script type="math/tex">P=P_1 \ldots P_n</script> and <code class="MathJax_Preview">P'=P'_1 \ldots P'_n</code><script type="math/tex">P'=P'_1 \ldots P'_n</script> two Pauli operators, with each <code class="MathJax_Preview">P_i</code><script type="math/tex">P_i</script> and <code class="MathJax_Preview">P'_i</code><script type="math/tex">P'_i</script> acting on qubit <code class="MathJax_Preview">i</code><script type="math/tex">i</script>. Our objective is to go from <code class="MathJax_Preview">PP'=P_1 \ldots P_n P'_1 \ldots P'_n</code><script type="math/tex">PP'=P_1 \ldots P_n P'_1 \ldots P'_n</script> to <code class="MathJax_Preview">P'P=P'_1 \ldots P'_n P_1 \ldots P_n</code><script type="math/tex">P'P=P'_1 \ldots P'_n P_1 \ldots P_n</script>.
For that, we will move each term <code class="MathJax_Preview">P'_i</code><script type="math/tex">P'_i</script> to the top. Since any <code class="MathJax_Preview">P'_i</code><script type="math/tex">P'_i</script> commute with all the terms <code class="MathJax_Preview">P_j</code><script type="math/tex">P_j</script> with <code class="MathJax_Preview">i \neq j</code><script type="math/tex">i \neq j</script> (they act on different qubits), we can move it next to <code class="MathJax_Preview">P_i</code><script type="math/tex">P_i</script>:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
PP'=P_1 \ldots P_i P'_i P_{i+1} \ldots P_n P'_1 \ldots P'_{i-1} P'_{i+1} \ldots P_n
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
PP'=P_1 \ldots P_i P'_i P_{i+1} \ldots P_n P'_1 \ldots P'_{i-1} P'_{i+1} \ldots P_n
\end{aligned}</script>

<p>Now, if <code class="MathJax_Preview">P</code><script type="math/tex">P</script> and <code class="MathJax_Preview">P'</code><script type="math/tex">P'</script> don’t intersect on qubit <code class="MathJax_Preview">i</code><script type="math/tex">i</script>, that is either <code class="MathJax_Preview">P_i=I</code><script type="math/tex">P_i=I</script> or <code class="MathJax_Preview">P'_i = I</code><script type="math/tex">P'_i = I</script>, we will have <code class="MathJax_Preview">P_i P'_i = P'_i P_i</code><script type="math/tex">P_i P'_i = P'_i P_i</script>. Same result if <code class="MathJax_Preview">P_i = P'_i</code><script type="math/tex">P_i = P'_i</script>. In those two cases, we can move <code class="MathJax_Preview">P'_i</code><script type="math/tex">P'_i</script> to the top without introducing any minus sign:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
PP'=P'_i P_1 \ldots P_n P'_1 \ldots P'_{i-1} P'_{i+1} \ldots P_n
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
PP'=P'_i P_1 \ldots P_n P'_1 \ldots P'_{i-1} P'_{i+1} \ldots P_n
\end{aligned}</script>

<p>On the other hand, if <code class="MathJax_Preview">P_i \neq P'_i \neq I</code><script type="math/tex">P_i \neq P'_i \neq I</script>, we will have <code class="MathJax_Preview">P_i P'_i = - P'_i P_i</code><script type="math/tex">P_i P'_i = - P'_i P_i</script> (remember that <code class="MathJax_Preview">XZ+ZX=XY+YX=YZ+ZY=0</code><script type="math/tex">XZ+ZX=XY+YX=YZ+ZY=0</script>). This means that moving <code class="MathJax_Preview">P'_i</code><script type="math/tex">P'_i</script> to the top introduces a minus sign:</p>

<pre class="MathJax_Preview"><code>\begin{aligned}
PP'=-P'_i P_1 \ldots P_n P'_1 \ldots P'_{i-1} P'_{i+1} \ldots P_n
\end{aligned}</code></pre>
<script type="math/tex; mode=display">\begin{aligned}
PP'=-P'_i P_1 \ldots P_n P'_1 \ldots P'_{i-1} P'_{i+1} \ldots P_n
\end{aligned}</script>

<p>Therefore, each intersection with a different Pauli element introduces a minus sign, and the overall sign will be <code class="MathJax_Preview">+1</code><script type="math/tex">+1</script> if and only if there is an even number of such intersections, which proves our propositions.</p>

<h2 id="solution-of-the-exercise">Solution of the exercise</h2>

<p class="message"><strong>Exercise</strong>: show that Shor’s code has a distance of <code class="MathJax_Preview">d=3</code><script type="math/tex">d=3</script>. <br />
<em>(<strong>Hint</strong>: find a weight-3 error, made of either <code class="MathJax_Preview">X</code><script type="math/tex">X</script> or <code class="MathJax_Preview">Z</code><script type="math/tex">Z</script> elements, that applies a bit-flip or phase-flip to the logical state of the code)</em><br /><br />
<strong>Correction</strong>: the operator <code class="MathJax_Preview">Z_1 Z_4 Z_7</code><script type="math/tex">Z_1 Z_4 Z_7</script> turns <code class="MathJax_Preview">\vert 0 \rangle_{L_2}</code><script type="math/tex">\vert 0 \rangle_{L_2}</script> into <code class="MathJax_Preview">\vert 1 \rangle_{L_2}</code><script type="math/tex">\vert 1 \rangle_{L_2}</script>, and is therefore a logical bit-flip operator. The operator <code class="MathJax_Preview">X_1 X_2 X_3</code><script type="math/tex">X_1 X_2 X_3</script> turns <code class="MathJax_Preview">\vert 1 \rangle_{L_2}</code><script type="math/tex">\vert 1 \rangle_{L_2}</script> into <code class="MathJax_Preview">-\vert 1 \rangle_{L_2}</code><script type="math/tex">-\vert 1 \rangle_{L_2}</script>, and is therefore a logical phase-flip operator. Note that those errors preserve the codespace (they turn a logical state into another logical state), and therefore cannot be detected by measuring our parity-check operators.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Note that I’m using a different notation from the previous post, giving variables a more generalizable name. If that confuses you, here is the exact mapping: <code class="MathJax_Preview">z_1 \rightarrow x_1</code><script type="math/tex">z_1 \rightarrow x_1</script>, <code class="MathJax_Preview">z_2 \rightarrow x_5</code><script type="math/tex">z_2 \rightarrow x_5</script>, <code class="MathJax_Preview">z_3 \rightarrow x_7</code><script type="math/tex">z_3 \rightarrow x_7</script>, <code class="MathJax_Preview">a \rightarrow x_2</code><script type="math/tex">a \rightarrow x_2</script>, <code class="MathJax_Preview">b \rightarrow x_3</code><script type="math/tex">b \rightarrow x_3</script>, <code class="MathJax_Preview">c \rightarrow x_6</code><script type="math/tex">c \rightarrow x_6</script>, <code class="MathJax_Preview">d \rightarrow x_4</code><script type="math/tex">d \rightarrow x_4</script>. <a href="#fnref:1" class="reversefootnote">&#x21a9;&#xfe0e;</a></p>
    </li>
    <li id="fn:2">
      <p>The <code class="MathJax_Preview">\vert 0 \rangle_{L}</code><script type="math/tex">\vert 0 \rangle_{L}</script> state of the Steane code was first implemented by an Austrian team, in <a href="https://arxiv.org/abs/1403.5426">Nigg et al., 2014</a>. Actual error correction using stabilizer measurements was then done by Honeywell in <a href="https://arxiv.org/abs/2107.07505">Ryan-Anderson et al., 2021</a>. <a href="#fnref:2" class="reversefootnote">&#x21a9;&#xfe0e;</a></p>
    </li>
  </ol>
</div>

  
</article>


<hr class="dingbat related" />




  
     



  

  
  

  
    




  

  
  


  
<aside class="comments related" role="complementary">
  <h2 class="hr">Comments</h2>
  

<div id="disqus_thread"></div>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<script>!function(w, d) {
  if (d.getElementById("disqus_thread")) {
    if (w.DISQUS) {
      w.DISQUS.reset({
        reload: true,
        config() {
          this.page.url = w.location.href;
          this.page.title = d.title;
        },
      });
    } else {
      w.disqus_config = function disqusConfig() {
        this.page.url = w.location.href;
        this.page.title = d.title;
      };
      w.loadJSDeferred(d.getElementById("_hrefDisqus").href + '/embed.js');
    }
  }
}(window, document);</script>


</aside>


  
<footer role="contentinfo">
  <hr/>
  
    <p><small class="copyright">© 2020. All rights reserved.
</small></p>
  
  
  <p><small>Powered by <a class="external" href="https://hydejack.com/">Hydejack</a> v<span id="_version">8.5.2</span></small></p>
  <hr class="sr-only"/>
</footer>


</main>

    <hy-drawer
  class=""
  align="left"
  threshold="10"
  touch-events
  prevent-default
>
  <header id="_sidebar" class="sidebar" role="banner">
    
    <div class="sidebar-bg sidebar-overlay" style="background-color:rgb(25,55,71);background-image:url(/assets/img/sidebar-bg.jpg)"></div>

    <div class="sidebar-sticky">
      <div class="sidebar-about">
        
          <a class="no-hover" href="/" tabindex="-1">
            <img src="/assets/icons/icon.png" class="avatar" alt="Arthur Pesah" data-ignore />
          </a>
        
        <h2 class="h1"><a href="/">Arthur Pesah</a></h2>
        
        
          <p class="">
            Researcher in quantum computing. PhD student at UCL (London)

          </p>
        
      </div>

      <nav class="sidebar-nav heading" role="navigation">
        <span class="sr-only">Navigation:</span>
<ul>
  
    
      
      <li>
        <a
          id="_navigation"
          href="/"
          class="sidebar-nav-item active"
          
        >
          Intro
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/blog/"
          class="sidebar-nav-item active"
          
        >
          Blog
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/publications/"
          class="sidebar-nav-item"
          
        >
          Publications
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/writing/"
          class="sidebar-nav-item"
          
        >
          Other writings
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/talks/"
          class="sidebar-nav-item"
          
        >
          Talks
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/animations/"
          class="sidebar-nav-item"
          
        >
          Animations
        </a>
      </li>
    
  
</ul>

      </nav>

      

      <div class="sidebar-social">
        <span class="sr-only">Social:</span>
<ul>
  
    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://twitter.com/artix41" title="Twitter" class="no-mark-external">
      <span class="icon-twitter"></span>
      <span class="sr-only">Twitter</span>
    </a>
  </li>


    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://github.com/artix41" title="GitHub" class="no-mark-external">
      <span class="icon-github"></span>
      <span class="sr-only">GitHub</span>
    </a>
  </li>


    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://www.linkedin.com/in/arthur-pesah" title="LinkedIn" class="no-mark-external">
      <span class="icon-linkedin2"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  </li>


    
  
</ul>

      </div>
    </div>
  </header>
</hy-drawer>
<hr class="sr-only" hidden />

  
</hy-push-state>

<!--[if gt IE 10]><!---->

  <script nomodule>!function(){var e=document.createElement("script");if(!("noModule"in e)&&"onbeforeload"in e){var t=!1;document.addEventListener("beforeload",function(n){if(n.target===e)t=!0;else if(!n.target.hasAttribute("nomodule")||!t)return;n.preventDefault()},!0),e.type="module",e.src=".",document.head.appendChild(e),e.remove()}}();
</script>
  <script type="module" src="/assets/js/hydejack-8.5.2.js"></script>
  <script nomodule src="/assets/js/hydejack-legacy-8.5.2.js" defer></script>
  

  
  <script>!function(w, d) {
    w.ga=w.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;

    /**/
      ga('create', 'UA-207151706-1', 'auto');
    /**/

    var pushStateEl = d.getElementsByTagName('hy-push-state')[0];
    var timeoutId;
    pushStateEl.addEventListener('hy-push-state-load', function() {
      w.clearTimeout(timeoutId);
      timeoutId = w.setTimeout(function() {
        ga('set', 'page', w.location.pathname);
        ga('send', 'pageview');
      }, 500);
    });

    d.addEventListener('hy--cookies-ok', function () {
      w.ga(function(tracker) {
        w.ga("set", "anonymizeIp", undefined);
        localStorage && localStorage.setItem("ga--client-id", tracker.get("clientId"));
      });
    });

    w.loadJSDeferred('https://www.google-analytics.com/analytics.js');
  }(window, document);</script>



<!--<![endif]-->




<h2 class="sr-only" hidden>Templates (for web app):</h2>

<template id="_animation-template" hidden>
  <div class="animation-main fixed-top">
    <div class="content">
      <div class="page"></div>
    </div>
  </div>
</template>

<template id="_loading-template" hidden>
  <div class="loading nav-btn fr">
    <span class="sr-only">Loading…</span>
    <span class="icon-cog"></span>
  </div>
</template>

<template id="_error-template" hidden>
  <div class="page">
    <h1 class="page-title">Error</h1>
    
    
    <p class="lead">
      Sorry, an error occurred while loading <a class="this-link" href=""></a>.

    </p>
  </div>
</template>

<template id="_forward-template" hidden>
  <button id="_forward" class="forward nav-btn no-hover fl">
    <span class="sr-only">Forward</span>
    <span class="icon-arrow-right2"></span>
  </button>
</template>

<template id="_back-template" hidden>
  <button id="_back" class="back nav-btn no-hover fl">
    <span class="sr-only">Back</span>
    <span class="icon-arrow-left2"></span>
  </button>
</template>

<template id="_permalink-template" hidden>
  <a href="#" class="permalink">
    <span class="sr-only">Permalink</span>
    <span class="icon-link"></span>
  </a>
</template>




</body>
</html>
